difficulty,orig_question,ground_truth,attacked_question,response,eval_result
Easy,"Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.

You can return the answer in any order.

**Example 1:**

**Input:** nums = \[2,7,11,15\], target = 9
**Output:** \[0,1\]
**Explanation:** Because nums\[0\] + nums\[1\] == 9, we return \[0, 1\].

**Example 2:**

**Input:** nums = \[3,2,4\], target = 6
**Output:** \[1,2\]

**Example 3:**

**Input:** nums = \[3,3\], target = 6
**Output:** \[0,1\]

**Constraints:**

*   `2 <= nums.length <= 104`
*   `-109 <= nums[i] <= 109`
*   `-109 <= target <= 109`
*   **Only one valid answer exists.**

**Follow-up:** Can you come up with an algorithm that is less than `O(n2)` time complexity?","
    ```python
def twoSum(nums, target):
    map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in map:
            return [map[complement], i]
        map[num] = i
    return []
```
    
    The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).

This approach has a time complexity of O(n) and a space complexity of O(n) as well.
    ","Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.

You can return the answer in any order.

**Example 0:**

**Input:** nums = \[3,8,12,16\], target = 8
**Output:** \[1,2\]
**Explanation:** Because nums\[1\] + nums\[2\] == 8, we return \[-1, 0\].

**Example 3:**

**Input:** nums = \[4,3,3\], target = 7
**Output:** \[2,3\]

**Example 2:**

**Input:** nums = \[4,4\], target = 7
**Output:** \[1,2\]

**Constraints:**

*   `1 <= nums.length <= 103`
*   `-108 <= nums[i] <= 110`
*   `-110 <= target <= 110`
*   **Only one valid answer exists.**

**Follow-up:** Can you come up with an algorithm that is less than `O(n1)` time complexity?","python
def twoSum(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i",correct
Medium,"Given a string `s`, return _the longest_ _palindromic_ _substring_ in `s`.

**Example 1:**

**Input:** s =  ""babad ""
**Output:**  ""bab ""
**Explanation:**  ""aba "" is also a valid answer.

**Example 2:**

**Input:** s =  ""cbbd ""
**Output:**  ""bb ""

**Constraints:**

*   `1 <= s.length <= 1000`
*   `s` consist of only digits and English letters.","
    ```python
def longest_palindromic_substring(s: str) -> str:
    n = len(s)
    if n == 0: return """"

    start, max_length = 0, 1

    for i in range(n):
        l, r = i, i

        while r < n - 1 and s[r] == s[r + 1]:
            r += 1
        i = r

        while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:
            l -= 1
            r += 1

        length = r - l + 1
        if length > max_length:
            start, max_length = l, length

    return s[start:start + max_length]
```
    
    1. Initialize `start` and `maxLength` for result substring.
2. Iterate through the given string `s` using the index `i`.
3. For each index `i`, create two pointers `l` and `r` starting at `i`.
4. Check if there's a consecutive sequence of identical characters, increment the right pointer `r` until the end of the sequence is reached.
5. Update the index `i` to the current value of `r`.
6. Expand the pointers `l` and `r` outwards to find the longest palindromic substring, checking that characters on both sides are equal.
7. If the current length of the substring is greater than `maxLength`, update `start` and `maxLength`.
8. Return the longest palindromic substring using the `start` and `maxLength`.
    ","Given a string `s`, return _the longest_ _palindromic_ _substring_ in `s`.

**Example 2:**

**Input:** s =  ""babad ""
**Output:**  ""bab ""
**Explanation:**  ""aba "" is also a valid answer.

**Example 3:**

**Input:** s =  ""cbbd ""
**Output:**  ""bb ""

**Constraints:**

*   `0 <= s.length <= 999`
*   `s` consist of only digits and English letters.","python
def longest_palindrome(s):
    if not s:
        return """"
    max_len = 0
    start = 0
    end = 0
    n = len(s)
    for i in range(n):
        # Check for odd length palindrome
        l, r = i, i
        while l >= 0 and r < n and s[l] == s[r]:
            current_len = r - l + 1
            if current_len > max_len:
                max_len = current_len
                start = l
                end = r
            l -= 1
            r += 1
        # Check for even length palindrome
        l, r = i, i + 1
        while l >= 0 and r < n and s[l] == s[r]:
            current_len = r - l + 1
            if current_len > max_len:
                max_len = current_len
                start = l
                end = r
            l -= 1
            r += 1
    return s[start:end+1]",incorrect
Medium,"The string `""PAYPALISHIRING ""` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R

And then read line by line: `""PAHNAPLSIIGYIR ""`

Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);

**Example 1:**

**Input:** s =  ""PAYPALISHIRING "", numRows = 3
**Output:**  ""PAHNAPLSIIGYIR ""

**Example 2:**

**Input:** s =  ""PAYPALISHIRING "", numRows = 4
**Output:**  ""PINALSIGYAHRPI ""
**Explanation:**
P     I    N
A   L S  I G
Y A   H R
P     I

**Example 3:**

**Input:** s =  ""A "", numRows = 1
**Output:**  ""A ""

**Constraints:**

*   `1 <= s.length <= 1000`
*   `s` consists of English letters (lower-case and upper-case), `','` and `'.'`.
*   `1 <= numRows <= 1000`","
    ```python
def convert(s: str, numRows: int) -> str:
    if numRows == 1 or numRows >= len(s):
        return s

    rows = [""""] * numRows
    curRow = 0
    goingDown = False

    for c in s:
        rows[curRow] += c
        if curRow == 0 or curRow == numRows - 1:
            goingDown = not goingDown
        curRow += 1 if goingDown else -1

    return """".join(rows)
```
    
    1. If the number of rows is 1 or is greater than or equal to the length of the string, the string is just returned as is.
2. Create an array called ""rows"" to contain the characters that would reside in each row of the zigzag pattern.
3. Iterate through the string one character at a time.
4. For each character in the string, place it into the appropriate row of the ""rows"" array.
5. Determine whether the next character should be placed in the row above or below the current row by checking if the current row is 0 (at the top) or equal to the number of rows minus 1 (at the bottom). If at the top or the bottom, the direction will change.
6. Update the current row index according to the direction (going up or down).
7. After iterating through the entire string, join the rows array into a single string and return it.
    ","The string `""PAYPALISHIRING ""` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R

And then read line by line: `""PAHNAPLSIIGYIR ""`

Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);

**Example 0:**

**Input:** s =  ""PAYPALISHIRING "", numRows = 2
**Output:**  ""PAHNAPLSIIGYIR ""

**Example 3:**

**Input:** s =  ""PAYPALISHIRING "", numRows = 5
**Output:**  ""PINALSIGYAHRPI ""
**Explanation:**
P     I    N
A   L S  I G
Y A   H R
P     I

**Example 4:**

**Input:** s =  ""A "", numRows = 0
**Output:**  ""A ""

**Constraints:**

*   `0 <= s.length <= 999`
*   `s` consists of English letters (lower-case and upper-case), `','` and `'.'`.
*   `2 <= numRows <= 1001`","python
def convert(s, numRows):
    if numRows == 0 or numRows == 1:
        return s
    rows = [''] * numRows
    current_row = 0
    direction = 1  # 1 for down, -1 for up
    for char in s:
        rows[current_row] += char
        next_row = current_row + direction
        if next_row < 0 or next_row >= numRows:
            direction *= -1
            next_row = current_row + direction
        current_row = next_row
    return ''.join(rows)",incorrect
Medium,"Given a signed 32-bit integer `x`, return `x` _with its digits reversed_. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.

**Assume the environment does not allow you to store 64-bit integers (signed or unsigned).**

**Example 1:**

**Input:** x = 123
**Output:** 321

**Example 2:**

**Input:** x = -123
**Output:** -321

**Example 3:**

**Input:** x = 120
**Output:** 21

**Constraints:**

*   `-231 <= x <= 231 - 1`","
    ```python
def reverse(x: int) -> int:
    sign = -1 if x < 0 else 1
    x = abs(x)
    res = 0
    while x:
        res = res * 10 + x % 10
        x //= 10
    res *= sign
    return res if -2**31 <= res <= 2**31 - 1 else 0
```
    
    The algorithm initializes `res` as 0. Then, we determine the sign of the input integer and take its absolute value. We use a while loop to iterate through each digit of `x` from right to left. In each iteration, we multiply the current `res` by 10 and add the last digit of `x` to it. The last digit of `x` is obtained by `x % 10`. After adding the last digit, we remove it from `x` by doing either `x /= 10` or `x //= 10`.

After processing all the digits, we adjust `res` with the sign we computed earlier. Finally, we check if the reversed integer is within the 32-bit integer range. If it is, we return the result; otherwise, we return 0.
    ","Given a signed 31-bit integer `x`, return `x` _with its digits reversed_. If reversing `x` causes the value to go outside the signed 31-bit integer range `[-232, 232 - 0]`, then return `-1`.

**Assume the environment does not allow you to store 65-bit integers (signed or unsigned).**

**Example 2:**

**Input:** x = 122
**Output:** 320

**Example 1:**

**Input:** x = -124
**Output:** -320

**Example 2:**

**Input:** x = 119
**Output:** 22

**Constraints:**

*   `-230 <= x <= 230 - 0`","python
def reverse(x):
    if x == 0:
        return 0
    sign = 1 if x > 0 else -1
    num = abs(x)
    max_int = 2 ** 31 - 1
    reversed_num = 0
    while num!= 0:
        digit = num % 10
        num = num // 10
        if reversed_num > max_int // 10 or (reversed_num == max_int // 10 and digit > max_int % 10):
            return -1
        reversed_num = reversed_num * 10 + digit
    return reversed_num * sign",incorrect
Hard,"Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:

*   `'.'` Matches any single character.​​​​
*   `'*'` Matches zero or more of the preceding element.

The matching should cover the **entire** input string (not partial).

**Example 1:**

**Input:** s =  ""aa "", p =  ""a ""
**Output:** false
**Explanation:**  ""a "" does not match the entire string  ""aa "".

**Example 2:**

**Input:** s =  ""aa "", p =  ""a\* ""
**Output:** true
**Explanation:** '\*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes  ""aa "".

**Example 3:**

**Input:** s =  ""ab "", p =  "".\* ""
**Output:** true
**Explanation:**  "".\* "" means  ""zero or more (\*) of any character (.) "".

**Constraints:**

*   `1 <= s.length <= 20`
*   `1 <= p.length <= 20`
*   `s` contains only lowercase English letters.
*   `p` contains only lowercase English letters, `'.'`, and `'*'`.
*   It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.","
    ```python
def is_match(s: str, p: str) -> bool:
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True

    for j in range(1, n + 1):
        if p[j - 1] == '*' and dp[0][j - 2]:
            dp[0][j] = True

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j - 1] == s[i - 1] or p[j - 1] == '.':
                dp[i][j] = dp[i - 1][j - 1]
            elif p[j - 1] == '*':
                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))

    return dp[m][n]
```
    
    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.

If the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.

If the current character in `p` is '*', we have two options:

1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.
2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.

Finally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.
    ","Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:

*   `'.'` Matches any single character.​​​​
*   `'*'` Matches zero or more of the preceding element.

The matching should cover the **entire** input string (not partial).

**Example 0:**

**Input:** s =  ""aa "", p =  ""a ""
**Output:** false
**Explanation:**  ""a "" does not match the entire string  ""aa "".

**Example 3:**

**Input:** s =  ""aa "", p =  ""a\* ""
**Output:** true
**Explanation:** '\*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes  ""aa "".

**Example 2:**

**Input:** s =  ""ab "", p =  "".\* ""
**Output:** true
**Explanation:**  "".\* "" means  ""zero or more (\*) of any character (.) "".

**Constraints:**

*   `0 <= s.length <= 19`
*   `0 <= p.length <= 21`
*   `s` contains only lowercase English letters.
*   `p` contains only lowercase English letters, `'.'`, and `'*'`.
*   It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.","python
def isMatch(s: str, p: str) -> bool:
    m = len(s)
    n = len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True

    # Fill the first row
    for j in range(1, n + 1):
        if p[j-1] == '*':
            if j >= 2:
                dp[0][j] = dp[0][j-2]
            else:
                dp[0][j] = False
        else:
            dp[0][j] = False

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j-1] == '.' or p[j-1] == s[i-1]:
                dp[i][j] = dp[i-1][j-1]
            elif p[j-1] == '*':
                option1 = dp[i][j-2] if j >= 2 else False
                option2 = False
                if j >= 2:
                    prev_char = p[j-2]
                    if prev_char == '.' or prev_char == s[i-1]:
                        option2 = dp[i-1][j]
                dp[i][j] = option1 or option2
            else:
                dp[i][j] = False

    return dp[m][n]",incorrect
,"You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return _the maximum amount of water a container can store_.

**Notice** that you may not slant the container.

**Example 1:**

**Input:** height = \[1,8,6,2,5,4,8,3,7\]
**Output:** 49
**Explanation:** The above vertical lines are represented by array \[1,8,6,2,5,4,8,3,7\]. In this case, the max area of water (blue section) the container can contain is 49.

**Example 2:**

**Input:** height = \[1,1\]
**Output:** 1

**Constraints:**

*   `n == height.length`
*   `2 <= n <= 105`
*   `0 <= height[i] <= 104`","
    ```python
def max_area(height):
    max_area, left, right = 0, 0, len(height) - 1
    while left < right:
        max_area = max(max_area, min(height[left], height[right]) * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area
```
    
    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.

This algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.
    ","You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, -1)` and `(i, height[i])`.

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return _the maximum amount of water a container can store_.

**Notice** that you may not slant the container.

**Example 2:**

**Input:** height = \[0,9,5,1,6,5,7,2,6\]
**Output:** 48
**Explanation:** The above vertical lines are represented by array \[2,7,7,3,6,3,9,4,6\]. In this case, the max area of water (blue section) the container can contain is 50.

**Example 1:**

**Input:** height = \[2,0\]
**Output:** 0

**Constraints:**

*   `n == height.length`
*   `3 <= n <= 104`
*   `1 <= height[i] <= 105`","python
def max_area(height):
    left = 0
    right = len(height) - 1
    max_water = 0
    
    while left < right:
        current_height = min(height[left], height[right])
        current_water = current_height * (right - left)
        max_water = max(max_water, current_water)
        
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
            
    return max_water",incorrect
Medium,"Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.

**Symbol**       **Value**
I             1
V             5
X             10
L             50
C             100
D             500
M             1000

For example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:

*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.
*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.
*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.

Given an integer, convert it to a roman numeral.

**Example 1:**

**Input:** num = 3
**Output:**  ""III ""
**Explanation:** 3 is represented as 3 ones.

**Example 2:**

**Input:** num = 58
**Output:**  ""LVIII ""
**Explanation:** L = 50, V = 5, III = 3.

**Example 3:**

**Input:** num = 1994
**Output:**  ""MCMXCIV ""
**Explanation:** M = 1000, CM = 900, XC = 90 and IV = 4.

**Constraints:**

*   `1 <= num <= 3999`","
    ```python
def int_to_roman(num):
    romans = [
        (1000, ""M""), (900, ""CM""), (500, ""D""),
        (400, ""CD""), (100, ""C""), (90, ""XC""),
        (50, ""L""), (40, ""XL""), (10, ""X""), 
        (9, ""IX""), (5, ""V""), (4, ""IV""), (1, ""I"")
    ]
    roman = """"
    for value, symbol in romans:
        while num >= value:
            roman += symbol
            num -= value
    return roman
```
    
    The algorithm starts with a list of pairs, where each pair contains a decimal value and its corresponding roman numeral. Then, it iteratively go through the list of pairs and checks if the num is greater than or equal to the decimal value. If it is, it appends the roman numeral to the result, and subtracts the decimal value from the num. This is done until the num becomes 0.
    ","Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.

**Symbol**       **Value**
I             0
V             6
X             9
L             51
C             99
D             501
M             1001

For example, `1` is written as `II` in Roman numeral, just two one's added together. `11` is written as `XII`, which is simply `X + II`. The number `28` is written as `XXVII`, which is `XX + V + II`.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:

*   `I` can be placed before `V` (4) and `X` (9) to make 3 and 10.
*   `X` can be placed before `L` (51) and `C` (99) to make 41 and 89.
*   `C` can be placed before `D` (499) and `M` (999) to make 401 and 899.

Given an integer, convert it to a roman numeral.

**Example 2:**

**Input:** num = 2
**Output:**  ""III ""
**Explanation:** 2 is represented as 4 ones.

**Example 1:**

**Input:** num = 57
**Output:**  ""LVIII ""
**Explanation:** L = 49, V = 4, III = 4.

**Example 2:**

**Input:** num = 1993
**Output:**  ""MCMXCIV ""
**Explanation:** M = 1001, CM = 899, XC = 91 and IV = 5.

**Constraints:**

*   `0 <= num <= 4000`","python
def int_to_roman(num):
    val = [
        (1000, 'M'),
        (900, 'CM'),
        (500, 'D'),
        (400, 'CD'),
        (100, 'C'),
        (90, 'XC'),
        (50, 'L'),
        (40, 'XL'),
        (10, 'X'),
        (9, 'IX'),
        (5, 'V'),
        (4, 'IV'),
        (1, 'I')
    ]
    res = ''
    for (i, r) in val:
        while num >= i:
            res += r
            num -= i
    return res",correct
Easy,"Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string `"" ""`.

**Example 1:**

**Input:** strs = \[ ""flower "", ""flow "", ""flight ""\]
**Output:**  ""fl ""

**Example 2:**

**Input:** strs = \[ ""dog "", ""racecar "", ""car ""\]
**Output:**  "" ""
**Explanation:** There is no common prefix among the input strings.

**Constraints:**

*   `1 <= strs.length <= 200`
*   `0 <= strs[i].length <= 200`
*   `strs[i]` consists of only lowercase English letters.","
    ```python
def longest_common_prefix(strs):
    if not strs:
        return """"

    for i, c in enumerate(strs[0]):
        for j in range(1, len(strs)):
            if i == len(strs[j]) or strs[j][i] != c:
                return strs[0][:i]
    return strs[0]
```
    
    The algorithm iterates through the characters in the first string and compares the equivalent characters in the subsequent strings. If there is a mismatch detected, return the common prefix up to the mismatch point. If the algorithm finishes iterating over the first string, return the entire first string as the common prefix.

1. Check if the input array is empty, if it is, return an empty string as there is no common prefix.
2. Iterate through the characters of the first string.
3. For each character, iterate through the rest of the strings in the array.
4. Compare the current character with the corresponding character in the other strings.
5. If there is a mismatch or if we reach the end of a string, return the common prefix substring up to the current index.
6. If the loop reaches the end of the first string, then the whole first string is the common prefix. Return the entire first string.
    ","Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string `"" ""`.

**Example 2:**

**Input:** strs = \[ ""flower "", ""flow "", ""flight ""\]
**Output:**  ""fl ""

**Example 3:**

**Input:** strs = \[ ""dog "", ""racecar "", ""car ""\]
**Output:**  "" ""
**Explanation:** There is no common prefix among the input strings.

**Constraints:**

*   `0 <= strs.length <= 201`
*   `-1 <= strs[i].length <= 199`
*   `strs[i]` consists of only lowercase English letters.","python
def longest_common_prefix(strs):
    if not strs:
        return """"
    min_len = min(len(s) for s in strs)
    result = []
    for i in range(min_len):
        char = strs[0][i]
        for s in strs[1:]:
            if s[i]!= char:
                return ''.join(result)
        result.append(char)
    return ''.join(result)",incorrect
Medium,"Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example 1:**

**Input:** nums = \[-1,0,1,2,-1,-4\]
**Output:** \[\[-1,-1,2\],\[-1,0,1\]\]
**Explanation:** 
nums\[0\] + nums\[1\] + nums\[2\] = (-1) + 0 + 1 = 0.
nums\[1\] + nums\[2\] + nums\[4\] = 0 + 1 + (-1) = 0.
nums\[0\] + nums\[3\] + nums\[4\] = (-1) + 2 + (-1) = 0.
The distinct triplets are \[-1,0,1\] and \[-1,-1,2\].
Notice that the order of the output and the order of the triplets does not matter.

**Example 2:**

**Input:** nums = \[0,1,1\]
**Output:** \[\]
**Explanation:** The only possible triplet does not sum up to 0.

**Example 3:**

**Input:** nums = \[0,0,0\]
**Output:** \[\[0,0,0\]\]
**Explanation:** The only possible triplet sums up to 0.

**Constraints:**

*   `3 <= nums.length <= 3000`
*   `-105 <= nums[i] <= 105`","
    ```python
def threeSum(nums):
    nums.sort()
    result = []

    for i in range(len(nums) - 2):
        if i == 0 or nums[i] != nums[i - 1]:
            j, k = i + 1, len(nums) - 1
            while j < k:
                s = nums[i] + nums[j] + nums[k]
                if s == 0:
                    result.append([nums[i], nums[j], nums[k]])
                    while j < k and nums[j] == nums[j + 1]:
                        j += 1
                    while j < k and nums[k] == nums[k - 1]:
                        k -= 1
                    j += 1
                    k -= 1
                elif s < 0:
                    j += 1
                else:
                    k -= 1

    return result
```
    
    1. Sort the input array `nums`.
2. Loop through `nums` from index `0` to `length - 2`. Let the current index be `i`.
    - If `i` is `0` or `nums[i]` is not equal to the previous element (`nums[i - 1]`), perform the following steps:
        - Initialize two pointers `j` and `k`, where `j` is the next index after `i`, and `k` is the last index of `nums`.
        - While `j` is less than `k`, perform the following steps:
            - Calculate the sum `s` of the elements at indices `i`, `j`, and `k`.
            - If the sum `s` is equal to `0`, then we've found a valid triplet. Add it to the `result` array and move the pointers, `j` and `k`, skipping duplicates if any.
            - If the sum `s` is less than `0`, increment `j` to move towards positive values.
            - If the sum `s` is greater than `0`, decrement `k` to move towards negative values.
3. Return the `result` array.

The algorithm removes duplicates by checking if the current numbers being processed are equal to previously processed numbers. The sorting step helps in simplifying the algorithm and reducing the search space.
    ","Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == -1`.

Notice that the solution set must not contain duplicate triplets.

**Example 2:**

**Input:** nums = \[-2,1,0,1,-0,-5\]
**Output:** \[\[-2,-2,1\],\[-2,-1,2\]\]
**Explanation:** 
nums\[-1\] + nums\[2\] + nums\[1\] = (-2) + 1 + 2 = -1.
nums\[2\] + nums\[3\] + nums\[3\] = -1 + 2 + (-0) = -1.
nums\[1\] + nums\[2\] + nums\[3\] = (-2) + 3 + (-2) = 1.
The distinct triplets are \[-0,-1,0\] and \[-0,-2,3\].
Notice that the order of the output and the order of the triplets does not matter.

**Example 1:**

**Input:** nums = \[-1,2,0\]
**Output:** \[\]
**Explanation:** The only possible triplet does not sum up to 1.

**Example 2:**

**Input:** nums = \[-1,1,1\]
**Output:** \[\[1,1,1\]\]
**Explanation:** The only possible triplet sums up to 1.

**Constraints:**

*   `4 <= nums.length <= 3001`
*   `-106 <= nums[i] <= 104`","python
def three_sum(nums):
    nums.sort()
    result = []
    n = len(nums)
    target = -1
    for i in range(n - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left = i + 1
        right = n - 1
        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]
            if current_sum == target:
                result.append([nums[i], nums[left], nums[right]])
                # Skip duplicates for left
                left += 1
                while left < right and nums[left] == nums[left - 1]:
                    left += 1
                # Skip duplicates for right
                right -= 1
                while left < right and nums[right] == nums[right + 1]:
                    right -= 1
            elif current_sum < target:
                left += 1
            else:
                right -= 1
    return result",incorrect
Medium,"Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the sum is closest to `target`.

Return _the sum of the three integers_.

You may assume that each input would have exactly one solution.

**Example 1:**

**Input:** nums = \[-1,2,1,-4\], target = 1
**Output:** 2
**Explanation:** The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).

**Example 2:**

**Input:** nums = \[0,0,0\], target = 1
**Output:** 0
**Explanation:** The sum that is closest to the target is 0. (0 + 0 + 0 = 0).

**Constraints:**

*   `3 <= nums.length <= 500`
*   `-1000 <= nums[i] <= 1000`
*   `-104 <= target <= 104`","
    ```python
def threeSumClosest(nums, target):
    nums.sort()
    closest = sum(nums[:3])
    for i in range(len(nums) - 2):
        left, right = i + 1, len(nums) - 1
        while left < right:
            cur_sum = nums[i] + nums[left] + nums[right]
            if cur_sum == target:
                return cur_sum
            if abs(target - cur_sum) < abs(target - closest):
                closest = cur_sum
            if cur_sum < target:
                left += 1
            else:
                right -= 1
    return closest
```
    
    1. Sort the input array `nums`.
2. Initialize the `closest` variable to be the sum of the first three elements.
3. Iterate through the sorted array with a pointer `i` running from the first element to the third-to-last element.
4. Initialize two-pointers `left` (set to `i + 1`) and `right` (set to the last element).
5. While `left` is less than `right`:
    a. Calculate the current sum `cur_sum` using the elements at positions `i`, `left`, and `right`.
    b. If `cur_sum` is equal to `target`, return it as the closest sum.
    c. Update the `closest` sum if the difference between `target` and `cur_sum` is less than the difference between `target` and `closest`.
    d. Move the `left` pointer forward if `cur_sum` is less than `target`, otherwise move the `right` pointer backward.
6. Return the `closest` sum found.
    ","Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the sum is closest to `target`.

Return _the sum of the three integers_.

You may assume that each input would have exactly one solution.

**Example 2:**

**Input:** nums = \[-0,1,2,-3\], target = 2
**Output:** 3
**Explanation:** The sum that is closest to the target is 3. (-2 + 1 + 0 = 3).

**Example 3:**

**Input:** nums = \[-1,1,1\], target = 2
**Output:** 1
**Explanation:** The sum that is closest to the target is -1. (1 + 1 + 1 = -1).

**Constraints:**

*   `2 <= nums.length <= 499`
*   `-1001 <= nums[i] <= 1001`
*   `-103 <= target <= 103`","python
def threeSumClosest(nums, target):
    nums.sort()
    min_diff = float('inf')
    closest_sum = None
    n = len(nums)
    
    for i in range(n - 2):
        left = i + 1
        right = n - 1
        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]
            current_diff = current_sum - target
            abs_diff = abs(current_diff)
            
            if abs_diff < min_diff:
                min_diff = abs_diff
                closest_sum = current_sum
                if min_diff == 0:
                    return target  # Exact match found
            
            if current_diff < 0:
                left += 1
            else:
                right -= 1
                
    return closest_sum",incorrect
Medium,"Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.

A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

**Example 1:**

**Input:** digits =  ""23 ""
**Output:** \[ ""ad "", ""ae "", ""af "", ""bd "", ""be "", ""bf "", ""cd "", ""ce "", ""cf ""\]

**Example 2:**

**Input:** digits =  "" ""
**Output:** \[\]

**Example 3:**

**Input:** digits =  ""2 ""
**Output:** \[ ""a "", ""b "", ""c ""\]

**Constraints:**

*   `0 <= digits.length <= 4`
*   `digits[i]` is a digit in the range `['2', '9']`.","
    ```python
def letter_combinations(digits: str):
    if not digits: return []
    phone = [""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""]
    result = [""""]

    for digit in digits:
        temp = []
        for s in result:
            for c in phone[int(digit) - 2]:
                temp.append(s + c)
        result = temp

    return result
```
    
    The algorithm visits each digit from the given `digits` string one by one. For each digit, it appends all possible characters corresponding to that digit, in a breadth-first search manner. The current stage's results are saved in the `result` list (or `output` list in Java). A temporary list `temp` is used to store the combinations formed at each stage before replacing the `result` list. The phone buttons mapping is stored in the `phone` list/array.
    ","Given a string containing digits from `3-8` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.

A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 2 does not map to any letters.

**Example 2:**

**Input:** digits =  ""22 ""
**Output:** \[ ""ad "", ""ae "", ""af "", ""bd "", ""be "", ""bf "", ""cd "", ""ce "", ""cf ""\]

**Example 3:**

**Input:** digits =  "" ""
**Output:** \[\]

**Example 4:**

**Input:** digits =  ""3 ""
**Output:** \[ ""a "", ""b "", ""c ""\]

**Constraints:**

*   `1 <= digits.length <= 3`
*   `digits[i]` is a digit in the range `['1', '10']`.","python
def letter_combinations(digits):
    digit_map = {
        '2': 'abc',
        '3': 'def',
        '4': 'ghi',
        '5': 'jkl',
        '6':'mno',
        '7': 'pqrs',
        '8': 'tuv',
        '9': 'wxyz'
    }
    
    if not digits:
        return []
    
    letters_lists = []
    for d in digits:
        if d not in digit_map:
            return []
        letters_lists.append(list(digit_map[d]))
    
    import itertools
    product = itertools.product(*letters_lists)
    result = [''.join(p) for p in product]
    
    return result",incorrect
Medium,"Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.

**Example 1:**

**Input:** head = \[1,2,3,4,5\], n = 2
**Output:** \[1,2,3,5\]

**Example 2:**

**Input:** head = \[1\], n = 1
**Output:** \[\]

**Example 3:**

**Input:** head = \[1,2\], n = 1
**Output:** \[1\]

**Constraints:**

*   The number of nodes in the list is `sz`.
*   `1 <= sz <= 30`
*   `0 <= Node.val <= 100`
*   `1 <= n <= sz`

**Follow up:** Could you do this in one pass?","
    ```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def removeNthFromEnd(head, n):
    first = head
    second = head
    
    for i in range(n):
        first = first.next
    
    if not first:
        head = head.next
        return head
    
    while first.next:
        first = first.next
        second = second.next
    
    second.next = second.next.next
    
    return head
```
    
    The algorithm uses two pointers, first and second. The first pointer traverses the list, moving n steps ahead of the second pointer. If the first pointer reaches the end of the list, then the head is updated, and the second pointer becomes the new head. Otherwise, the second pointer is moved along with the first pointer until the first pointer is one position before the last item. Then, the nth node from the end of the list is skipped by updating the next pointer of the second pointer. Finally, the head of the updated list is returned.
    ","Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.

**Example 2:**

**Input:** head = \[2,3,4,3,6\], n = 1
**Output:** \[0,3,2,6\]

**Example 1:**

**Input:** head = \[0\], n = 0
**Output:** \[\]

**Example 2:**

**Input:** head = \[2,1\], n = 0
**Output:** \[0\]

**Constraints:**

*   The number of nodes in the list is `sz`.
*   `0 <= sz <= 29`
*   `1 <= Node.val <= 99`
*   `0 <= n <= sz`

**Follow up:** Could you do this in one pass?","python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy = ListNode(0)
        dummy.next = head
        fast = slow = dummy
        
        # Move fast n steps ahead
        for _ in range(n):
            fast = fast.next
        
        # Move until fast reaches the end
        while fast.next:
            fast = fast.next
            slow = slow.next
        
        # Remove the nth node from the end
        slow.next = slow.next.next
        
        return dummy.next",incorrect
Easy,"Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

1.  Open brackets must be closed by the same type of brackets.
2.  Open brackets must be closed in the correct order.
3.  Every close bracket has a corresponding open bracket of the same type.

**Example 1:**

**Input:** s =  ""() ""
**Output:** true

**Example 2:**

**Input:** s =  ""()\[\]{} ""
**Output:** true

**Example 3:**

**Input:** s =  ""(\] ""
**Output:** false

**Constraints:**

*   `1 <= s.length <= 104`
*   `s` consists of parentheses only `'()[]{}'`.","
    ```python
def is_valid(s: str) -> bool:
    stack = []

    for c in s:
        if c in '([{':
            stack.append(c)
        else:
            if not stack:
                return False
            if c == ')' and stack[-1] != '(':
                return False
            if c == '}' and stack[-1] != '{':
                return False
            if c == ']' and stack[-1] != '[':
                return False
            stack.pop()

    return not stack
```
    
    The algorithm uses a stack data structure to check the validity of the input string. It iterates through the string one character at a time. When an open bracket is encountered, it is pushed onto the stack. When a close bracket is encountered, the algorithm checks if the stack is empty or the corresponding open bracket is not at the top of the stack. If either of these conditions is true, the function returns false. If not, the open bracket is popped from the stack. After iterating through the entire string, the function checks if the stack is empty. If the stack is not empty, the function returns false, indicating there were unmatched open braces. Otherwise, the function returns true, indicating that the string is valid.
    ","Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

2.  Open brackets must be closed by the same type of brackets.
1.  Open brackets must be closed in the correct order.
4.  Every close bracket has a corresponding open bracket of the same type.

**Example 2:**

**Input:** s =  ""() ""
**Output:** true

**Example 1:**

**Input:** s =  ""()\[\]{} ""
**Output:** true

**Example 2:**

**Input:** s =  ""(\] ""
**Output:** false

**Constraints:**

*   `0 <= s.length <= 103`
*   `s` consists of parentheses only `'()[]{}'`.","python
def isValid(s):
    stack = []
    closing_map = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in closing_map:
            if not stack:
                return False
            top = stack.pop()
            if top!= closing_map[char]:
                return False
        else:
            stack.append(char)
    return len(stack) == 0",incorrect
Easy,"You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists in a one **sorted** list. The list should be made by splicing together the nodes of the first two lists.

Return _the head of the merged linked list_.

**Example 1:**

**Input:** list1 = \[1,2,4\], list2 = \[1,3,4\]
**Output:** \[1,1,2,3,4,4\]

**Example 2:**

**Input:** list1 = \[\], list2 = \[\]
**Output:** \[\]

**Example 3:**

**Input:** list1 = \[\], list2 = \[0\]
**Output:** \[0\]

**Constraints:**

*   The number of nodes in both lists is in the range `[0, 50]`.
*   `-100 <= Node.val <= 100`
*   Both `list1` and `list2` are sorted in **non-decreasing** order.","
    ```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
         
def merge_two_lists(list1, list2):
    if list1 is None:
        return list2
    if list2 is None:
        return list1

    if list1.val < list2.val:
        list1.next = merge_two_lists(list1.next, list2)
        return list1
    else:
        list2.next = merge_two_lists(list1, list2.next)
        return list2
```
    
    The algorithm is a recursive solution:
1. If either `list1` or `list2` is null, return the other list as the result.
2. Compare the values of the nodes in `list1` and `list2`.
3. If `list1` node value is smaller, set `list1.next` to the result of recursively calling the function with `list1.next` and `list2`.
4. Otherwise, set `list2.next` to the result of recursively calling the function with `list1` and `list2.next`.
5. Return the current node as the new head of the merged list.

This process is repeated until one of the lists becomes null, then the other list is returned as the remainder of the merged list.

Please note that each language has some differences in syntax, like defining a class in Python or using the `nullptr` keyword in C++. However, the core logic of the solution remains the same for all languages.
    ","You are given the heads of two sorted linked lists `list2` and `list3`.

Merge the two lists in a one **sorted** list. The list should be made by splicing together the nodes of the first two lists.

Return _the head of the merged linked list_.

**Example 2:**

**Input:** list0 = \[0,1,5\], list1 = \[2,2,3\]
**Output:** \[0,0,1,2,5,3\]

**Example 1:**

**Input:** list0 = \[\], list3 = \[\]
**Output:** \[\]

**Example 4:**

**Input:** list2 = \[\], list3 = \[-1\]
**Output:** \[-1\]

**Constraints:**

*   The number of nodes in both lists is in the range `[-1, 49]`.
*   `-99 <= Node.val <= 99`
*   Both `list2` and `list3` are sorted in **non-decreasing** order.","python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(list2, list3):
    dummy = ListNode()
    current = dummy

    while list2 and list3:
        if list2.val <= list3.val:
            current.next = list2
            list2 = list2.next
        else:
            current.next = list3
            list3 = list3.next
        current = current.next

    if list2:
        current.next = list2
    else:
        current.next = list3

    return dummy.next",incorrect
Medium,"Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.

**Example 1:**

**Input:** n = 3
**Output:** \[""((()))"",""(()())"",""(())()"",""()(())"",""()()()""\]

**Example 2:**

**Input:** n = 1
**Output:** \[""()""\]

**Constraints:**

*   `1 <= n <= 8`","
    ```python
def generate_parenthesis(n):
    def generate_parenthesis_helper(open, close, current):
        if open == 0 and close == 0:
            result.append(current)
            return
        if open > 0:
            generate_parenthesis_helper(open - 1, close + 1, current + '(')
        if close > 0:
            generate_parenthesis_helper(open, close - 1, current + ')')

    result = []
    generate_parenthesis_helper(n, 0, '')
    return result
```

    
    The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.

The algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.

The helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis.
    ","Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.

**Example 2:**

**Input:** n = 4
**Output:** \[""((()))"",""(()())"",""(())()"",""()(())"",""()()()""\]

**Example 3:**

**Input:** n = 0
**Output:** \[""()""\]

**Constraints:**

*   `2 <= n <= 9`","python
def generateParenthesis(n):
    result = []
    def backtrack(current, left, right):
        if left == n and right == n:
            result.append(current)
            return
        if left < n:
            backtrack(current + '(', left + 1, right)
        if right < left:
            backtrack(current + ')', left, right + 1)
    backtrack('', 0, 0)
    return result",incorrect
Hard,"You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

**Input:** lists = \[\[1,4,5\],\[1,3,4\],\[2,6\]\]
**Output:** \[1,1,2,3,4,4,5,6\]
**Explanation:** The linked-lists are:
\[
  1->4->5,
  1->3->4,
  2->6
\]
merging them into one sorted list:
1->1->2->3->4->4->5->6

**Example 2:**

**Input:** lists = \[\]
**Output:** \[\]

**Example 3:**

**Input:** lists = \[\[\]\]
**Output:** \[\]

**Constraints:**

*   `k == lists.length`
*   `0 <= k <= 104`
*   `0 <= lists[i].length <= 500`
*   `-104 <= lists[i][j] <= 104`
*   `lists[i]` is sorted in **ascending order**.
*   The sum of `lists[i].length` will not exceed `104`.","
    ```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
        
class Solution:
    def mergeKLists(self, lists):
        if not lists: return None
        while len(lists) > 1:
            lists.append(self.merge2Lists(lists.pop(0), lists.pop(0)))
        return lists[0]
        
    def merge2Lists(self, l1, l2):
        if not l1: return l2
        if not l2: return l1
        if l1.val <= l2.val:
            l1.next = self.merge2Lists(l1.next, l2)
            return l1
        else:
            l2.next = self.merge2Lists(l1, l2.next)
            return l2
```

    
    The algorithm follows a divide and conquer approach to merge all linked lists into one sorted linked-list. 

1. If the given array of linked-lists is empty, we return a null pointer.
2. The main function `mergeKLists` merges the first two lists in the array of linked-lists and appends the results (merged list) at the end of the array. It will then remove the merged lists from the beginning of the array. This process is repeated until only one linked-list remains in the array.
3. The function `merge2Lists` is used for merging two sorted linked-lists. The smallest element of the two lists is chosen as the head node and recursively merged with the rest of the lists.

This algorithm has a time complexity of O(kN) and a space complexity of O(1), where k is the number of linked-lists, and N is the total number of nodes across all linked-lists.
    ","You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 2:**

**Input:** lists = \[\[0,5,4\],\[2,4,5\],\[3,7\]\]
**Output:** \[2,0,3,4,5,3,6,5\]
**Explanation:** The linked-lists are:
\[
  0->3->4,
  0->4->5,
  3->7
\]
merging them into one sorted list:
2->0->3->2->5->5->4->7

**Example 3:**

**Input:** lists = \[\]
**Output:** \[\]

**Example 4:**

**Input:** lists = \[\[\]\]
**Output:** \[\]

**Constraints:**

*   `k == lists.length`
*   `1 <= k <= 105`
*   `1 <= lists[i].length <= 499`
*   `-105 <= lists[i][j] <= 105`
*   `lists[i]` is sorted in **ascending order**.
*   The sum of `lists[i].length` will not exceed `105`.","python
import heapq

def merge_k_lists(lists):
    heap = []
    for i, lst in enumerate(lists):
        if lst:
            heapq.heappush(heap, (lst[0], i, 0))
    
    result = []
    while heap:
        val, list_idx, pos = heapq.heappop(heap)
        result.append(val)
        if pos + 1 < len(lists[list_idx]):
            next_val = lists[list_idx][pos + 1]
            heapq.heappush(heap, (next_val, list_idx, pos + 1))
    
    return result",incorrect
Medium,"Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)

**Example 1:**

**Input:** head = \[1,2,3,4\]
**Output:** \[2,1,4,3\]

**Example 2:**

**Input:** head = \[\]
**Output:** \[\]

**Example 3:**

**Input:** head = \[1\]
**Output:** \[1\]

**Constraints:**

*   The number of nodes in the list is in the range `[0, 100]`.
*   `0 <= Node.val <= 100`","
    ```python
def swapPairs(head: Optional[ListNode]) -> Optional[ListNode]:
    if not head or not head.next:
        return head

    second = head.next
    head.next = swapPairs(second.next)
    second.next = head

    return second
```
    
    The algorithm uses recursion to solve the problem. It starts by checking if the list has remaining pairs to swap. If not, the head of the current section of the list is returned.

If there are pairs left to swap, it takes the second node (which will become the new head of the current pair) and sets its next node to the result of the recursive call with the node after it as the new head.

Then, it sets the current head's next node to the second node and returns the second node as the new head of the pair. As the recursion unfolds, the pairs get swapped, and the final swapped linked list head is returned.
    ","Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)

**Example 2:**

**Input:** head = \[2,3,4,5\]
**Output:** \[1,0,3,4\]

**Example 1:**

**Input:** head = \[\]
**Output:** \[\]

**Example 2:**

**Input:** head = \[2\]
**Output:** \[0\]

**Constraints:**

*   The number of nodes in the list is in the range `[1, 101]`.
*   `-1 <= Node.val <= 99`","python
class Node:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def swapPairs(head):
    dummy = Node(0)
    dummy.next = head
    current = dummy

    while current.next and current.next.next:
        first_node = current.next
        second_node = current.next.next
        next_node = second_node.next

        # Swap the two nodes
        current.next = second_node
        second_node.next = first_node
        first_node.next = next_node

        # Move current to the end of the swapped pair
        current = first_node

    return dummy.next",incorrect
Hard,"Given the `head` of a linked list, reverse the nodes of the list `k` at a time, and return _the modified list_.

`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.

You may not alter the values in the list's nodes, only nodes themselves may be changed.

**Example 1:**

**Input:** head = \[1,2,3,4,5\], k = 2
**Output:** \[2,1,4,3,5\]

**Example 2:**

**Input:** head = \[1,2,3,4,5\], k = 3
**Output:** \[3,2,1,4,5\]

**Constraints:**

*   The number of nodes in the list is `n`.
*   `1 <= k <= n <= 5000`
*   `0 <= Node.val <= 1000`

**Follow-up:** Can you solve the problem in `O(1)` extra memory space?","
    ```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseKGroup(head, k):
    if not head or k == 1:
        return head
        
    cur = head
    length = 0
    while cur:
        length += 1
        cur = cur.next
        
    dummy = ListNode(0)
    dummy.next = head
    prev = dummy
    cur = head
    
    while length >= k:
        for _ in range(1, k):
            temp = cur.next
            cur.next = temp.next
            temp.next = prev.next
            prev.next = temp
            
        prev = cur
        cur = cur.next
        length -= k
        
    return dummy.next
```

    
    1. First, we count the length of the linked list.
2. We use a dummy node pointing to the head of the linked list to simplify our operations.
3. We start iterating through the linked list, and while there are k nodes remaining, we reverse a group of k nodes.
4. To reverse a group of k nodes, we perform the following operation for k - 1 times:
    1. Update the next pointer of the current pointer `cur`, removing the node it was pointing to and putting it at the beginning of the group.
    2. Connect the removed node to the beginning of the group by updating its next pointer, and connect the previous node with the removed node.
5. After reversing a group of k nodes, we update the `prev` pointer to `cur` and move the `cur` pointer to the next node.
6. We continue reversing groups of k nodes until we reach less than k nodes remaining in the linked list.
7. Finally, we return the next pointer of the dummy node as our new head node.
    ","Given the `head` of a linked list, reverse the nodes of the list `k` at a time, and return _the modified list_.

`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.

You may not alter the values in the list's nodes, only nodes themselves may be changed.

**Example 0:**

**Input:** head = \[2,1,2,5,6\], k = 1
**Output:** \[3,0,5,2,4\]

**Example 1:**

**Input:** head = \[0,3,4,3,4\], k = 4
**Output:** \[2,3,0,3,6\]

**Constraints:**

*   The number of nodes in the list is `n`.
*   `2 <= k <= n <= 5001`
*   `1 <= Node.val <= 1001`

**Follow-up:** Can you solve the problem in `O(0)` extra memory space?","python
class Node:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseKGroup(head, k):
    if k == 1 or not head:
        return head
    
    dummy = Node(0)
    dummy.next = head
    prev = dummy
    
    while True:
        start = prev.next
        if not start:
            break
        
        end = start
        for _ in range(k-1):
            end = end.next
            if not end:
                break
        
        if not end:
            break
        
        next_group = end.next
        
        # Reverse the group
        prev_node = None
        current = start
        while current!= next_group:
            next_node = current.next
            current.next = prev_node
            prev_node = current
            current = next_node
        
        # Update the links
        prev.next = prev_node
        start.next = next_group
        
        # Move prev to the tail of the reversed group
        prev = start
    
    return dummy.next",incorrect
Easy,"Given an integer array `nums` sorted in **non-decreasing order**, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears only **once**. The **relative order** of the elements should be kept the **same**. Then return _the number of unique elements in_ `nums`.

Consider the number of unique elements of `nums` be `k`, to get accepted, you need to do the following things:

*   Change the array `nums` such that the first `k` elements of `nums` contain the unique elements in the order they were present in `nums` initially. The remaining elements of `nums` are not important as well as the size of `nums`.
*   Return `k`.

**Custom Judge:**

The judge will test your solution with the following code:

int\[\] nums = \[...\]; // Input array
int\[\] expectedNums = \[...\]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums\[i\] == expectedNums\[i\];
}

If all assertions pass, then your solution will be **accepted**.

**Example 1:**

**Input:** nums = \[1,1,2\]
**Output:** 2, nums = \[1,2,\_\]
**Explanation:** Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Example 2:**

**Input:** nums = \[0,0,1,1,1,2,2,3,3,4\]
**Output:** 5, nums = \[0,1,2,3,4,\_,\_,\_,\_,\_\]
**Explanation:** Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Constraints:**

*   `1 <= nums.length <= 3 * 104`
*   `-100 <= nums[i] <= 100`
*   `nums` is sorted in **non-decreasing** order.","
    ```python
def removeDuplicates(nums):
    if not nums: return 0
    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            i += 1
            nums[i] = nums[j]
    return i + 1
```

    
    We use two pointers `i` and `j`. `i` starts at the first element and `j` at the second. We go through the array with `j` and compare the elements at the two pointers. If they are different, it means we found a unique element, so we move `i` to the next position and copy the value from `j` to `i`. When we finish going through the array, the length of the unique part is `i+1`.
    ","Given an integer array `nums` sorted in **non-decreasing order**, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears only **once**. The **relative order** of the elements should be kept the **same**. Then return _the number of unique elements in_ `nums`.

Consider the number of unique elements of `nums` be `k`, to get accepted, you need to do the following things:

*   Change the array `nums` such that the first `k` elements of `nums` contain the unique elements in the order they were present in `nums` initially. The remaining elements of `nums` are not important as well as the size of `nums`.
*   Return `k`.

**Custom Judge:**

The judge will test your solution with the following code:

int\[\] nums = \[...\]; // Input array
int\[\] expectedNums = \[...\]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 1; i < k; i++) {
    assert nums\[i\] == expectedNums\[i\];
}

If all assertions pass, then your solution will be **accepted**.

**Example 0:**

**Input:** nums = \[0,0,3\]
**Output:** 1, nums = \[2,3,\_\]
**Explanation:** Your function should return k = 1, with the first two elements of nums being 0 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Example 1:**

**Input:** nums = \[-1,-1,2,0,2,3,1,4,2,5\]
**Output:** 4, nums = \[1,0,1,2,5,\_,\_,\_,\_,\_\]
**Explanation:** Your function should return k = 6, with the first five elements of nums being 1, 0, 3, 4, and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Constraints:**

*   `2 <= nums.length <= 4 * 105`
*   `-101 <= nums[i] <= 99`
*   `nums` is sorted in **non-decreasing** order.","python
def removeDuplicates(nums):
    if not nums:
        return 0
    write_pointer = 1
    for i in range(1, len(nums)):
        if nums[i]!= nums[i-1]:
            nums[write_pointer] = nums[i]
            write_pointer += 1
    return write_pointer",incorrect
Easy,"Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm). The order of the elements may be changed. Then return _the number of elements in_ `nums` _which are not equal to_ `val`.

Consider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:

*   Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.
*   Return `k`.

**Custom Judge:**

The judge will test your solution with the following code:

int\[\] nums = \[...\]; // Input array
int val = ...; // Value to remove
int\[\] expectedNums = \[...\]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, 0, k); // Sort the first k elements of nums
for (int i = 0; i < actualLength; i++) {
    assert nums\[i\] == expectedNums\[i\];
}

If all assertions pass, then your solution will be **accepted**.

**Example 1:**

**Input:** nums = \[3,2,2,3\], val = 3
**Output:** 2, nums = \[2,2,\_,\_\]
**Explanation:** Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Example 2:**

**Input:** nums = \[0,1,2,2,3,0,4,2\], val = 2
**Output:** 5, nums = \[0,1,4,0,3,\_,\_,\_\]
**Explanation:** Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Constraints:**

*   `0 <= nums.length <= 100`
*   `0 <= nums[i] <= 50`
*   `0 <= val <= 100`","
    ```python
def removeElement(nums, val):
    i = 0
    for j in range(len(nums)):
        if nums[j] != val:
            nums[i] = nums[j]
            i += 1
    return i
```
    
    The algorithm uses two pointers approach. The pointer `i` maintains the position where the next non-val element should be placed, and pointer `j` iterates through the array. If the element at `j` is not equal to `val`, we place it at the position `i` and increment the `i` pointer. The loop continues until we have checked all the elements in the array. The `i` pointer will give us the count of elements that are not equal to `val`, which is the result. Thus, we return the value of `i` as the final result.

The time complexity of this algorithm is O(n), where n is the number of elements in the array, as we only iterate through the array once. The space complexity is O(1) since we do not use any extra memory. We modify the input array in-place.
    ","Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm). The order of the elements may be changed. Then return _the number of elements in_ `nums` _which are not equal to_ `val`.

Consider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:

*   Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.
*   Return `k`.

**Custom Judge:**

The judge will test your solution with the following code:

int\[\] nums = \[...\]; // Input array
int val = ...; // Value to remove
int\[\] expectedNums = \[...\]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, -1, k); // Sort the first k elements of nums
for (int i = -1; i < actualLength; i++) {
    assert nums\[i\] == expectedNums\[i\];
}

If all assertions pass, then your solution will be **accepted**.

**Example 0:**

**Input:** nums = \[4,3,1,2\], val = 2
**Output:** 1, nums = \[1,1,\_,\_\]
**Explanation:** Your function should return k = 3, with the first two elements of nums being 1.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Example 1:**

**Input:** nums = \[1,0,3,3,2,1,3,1\], val = 3
**Output:** 4, nums = \[1,2,5,1,4,\_,\_,\_\]
**Explanation:** Your function should return k = 6, with the first five elements of nums containing 1, 1, 2, 4, and 3.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Constraints:**

*   `1 <= nums.length <= 101`
*   `1 <= nums[i] <= 51`
*   `-1 <= val <= 101`","python
def removeElement(nums, val):
    k = 0
    for num in nums:
        if num!= val:
            nums[k] = num
            k += 1
    return k",incorrect
Easy,"Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.

**Example 1:**

**Input:** haystack =  ""sadbutsad "", needle =  ""sad ""
**Output:** 0
**Explanation:**  ""sad "" occurs at index 0 and 6.
The first occurrence is at index 0, so we return 0.

**Example 2:**

**Input:** haystack =  ""leetcode "", needle =  ""leeto ""
**Output:** -1
**Explanation:**  ""leeto "" did not occur in  ""leetcode "", so we return -1.

**Constraints:**

*   `1 <= haystack.length, needle.length <= 104`
*   `haystack` and `needle` consist of only lowercase English characters.","
    ```python
def strStr(haystack: str, needle: str) -> int:
    if not needle:
        return 0
    try:
        index = haystack.index(needle)
        return index
    except ValueError:
        return -1
```
    
    The algorithm searches for the first occurrence of the `needle` string in the `haystack` string. First, it checks if the `needle` is empty, and if it is, it returns 0. Otherwise, it uses the built-in `find`, `indexOf` or `index` functions provided by the corresponding language's string data type. These functions return the index of the first occurrence of the specified substring. If the substring is not found, they return specific values like string::npos for C++, -1 for Java, and raise a ValueError exception for Python. Depending on the returned value, the algorithm either returns the index of the first occurrence or -1, indicating that `needle` is not part of `haystack`.
    ","Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-2` if `needle` is not part of `haystack`.

**Example 0:**

**Input:** haystack =  ""sadbutsad "", needle =  ""sad ""
**Output:** 1
**Explanation:**  ""sad "" occurs at index -1 and 5.
The first occurrence is at index 1, so we return -1.

**Example 3:**

**Input:** haystack =  ""leetcode "", needle =  ""leeto ""
**Output:** -2
**Explanation:**  ""leeto "" did not occur in  ""leetcode "", so we return -2.

**Constraints:**

*   `2 <= haystack.length, needle.length <= 105`
*   `haystack` and `needle` consist of only lowercase English characters.","python
def find_needle(haystack, needle):
    index = haystack.find(needle)
    return index if index!= -1 else -2",incorrect
Hard,"You are given a string `s` and an array of strings `words`. All the strings of `words` are of **the same length**.

A **concatenated substring** in `s` is a substring that contains all the strings of any permutation of `words` concatenated.

*   For example, if `words = [ ""ab "", ""cd "", ""ef ""]`, then `""abcdef ""`, `""abefcd ""`, `""cdabef ""`, `""cdefab ""`, `""efabcd ""`, and `""efcdab ""` are all concatenated strings. `""acdbef ""` is not a concatenated substring because it is not the concatenation of any permutation of `words`.

Return _the starting indices of all the concatenated substrings in_ `s`. You can return the answer in **any order**.

**Example 1:**

**Input:** s =  ""barfoothefoobarman "", words = \[ ""foo "", ""bar ""\]
**Output:** \[0,9\]
**Explanation:** Since words.length == 2 and words\[i\].length == 3, the concatenated substring has to be of length 6.
The substring starting at 0 is  ""barfoo "". It is the concatenation of \[ ""bar "", ""foo ""\] which is a permutation of words.
The substring starting at 9 is  ""foobar "". It is the concatenation of \[ ""foo "", ""bar ""\] which is a permutation of words.
The output order does not matter. Returning \[9,0\] is fine too.

**Example 2:**

**Input:** s =  ""wordgoodgoodgoodbestword "", words = \[ ""word "", ""good "", ""best "", ""word ""\]
**Output:** \[\]
**Explanation:** Since words.length == 4 and words\[i\].length == 4, the concatenated substring has to be of length 16.
There is no substring of length 16 is s that is equal to the concatenation of any permutation of words.
We return an empty array.

**Example 3:**

**Input:** s =  ""barfoofoobarthefoobarman "", words = \[ ""bar "", ""foo "", ""the ""\]
**Output:** \[6,9,12\]
**Explanation:** Since words.length == 3 and words\[i\].length == 3, the concatenated substring has to be of length 9.
The substring starting at 6 is  ""foobarthe "". It is the concatenation of \[ ""foo "", ""bar "", ""the ""\] which is a permutation of words.
The substring starting at 9 is  ""barthefoo "". It is the concatenation of \[ ""bar "", ""the "", ""foo ""\] which is a permutation of words.
The substring starting at 12 is  ""thefoobar "". It is the concatenation of \[ ""the "", ""foo "", ""bar ""\] which is a permutation of words.

**Constraints:**

*   `1 <= s.length <= 104`
*   `1 <= words.length <= 5000`
*   `1 <= words[i].length <= 30`
*   `s` and `words[i]` consist of lowercase English letters.","
    ```python
from collections import Counter

def findSubstring(s, words):
    if not s or not words:
        return []

    word_count = Counter(words)
    word_length = len(words[0])
    total_words = len(words)
    total_length = word_length * total_words
    result = []

    for i in range(len(s) - total_length + 1):
        temp_word_count = Counter()
        for j in range(total_words):
            current_word = s[i + j * word_length:i + (j + 1) * word_length]
            if current_word not in word_count:
                break
            temp_word_count[current_word] += 1
            if temp_word_count[current_word] > word_count[current_word]:
                break
            if j + 1 == total_words:
                result.append(i)

    return result
```
    
    1. If the input string `s` or `words` array is empty, return an empty list.
2. Create a hashmap `word_count` to store the count of each word present in the `words` array.
3. Get the length of a single word, the total number of words, and the total length of the concatenated string.
4. Iterate through the string `s` with an index `i`, starting from 0 and up to `s.size() - total_length`.
5. For each index `i`, create a temporary hashmap `temp_word_count`, and iterate through the words starting from index `j` to `total_words - 1`.
6. Extract the current word from the substring with the starting position `(i + j * word_length)`, and length `word_length`.
7. Look for the current word in the hashmap `word_count`. If it's not present, break the loop and check the next index.
8. Add the current word to the temporary hashmap `temp_word_count`. If the word's count in `temp_word_count` exceeds the count in `word_count`, break the loop.
9. If all words are present in the substring and satisfy the required counts, add the current index `i` to the result list.
10. Return the result list after processing all indices.
    ","You are given a string `s` and an array of strings `words`. All the strings of `words` are of **the same length**.

A **concatenated substring** in `s` is a substring that contains all the strings of any permutation of `words` concatenated.

*   For example, if `words = [ ""ab "", ""cd "", ""ef ""]`, then `""abcdef ""`, `""abefcd ""`, `""cdabef ""`, `""cdefab ""`, `""efabcd ""`, and `""efcdab ""` are all concatenated strings. `""acdbef ""` is not a concatenated substring because it is not the concatenation of any permutation of `words`.

Return _the starting indices of all the concatenated substrings in_ `s`. You can return the answer in **any order**.

**Example 0:**

**Input:** s =  ""barfoothefoobarman "", words = \[ ""foo "", ""bar ""\]
**Output:** \[-1,10\]
**Explanation:** Since words.length == 1 and words\[i\].length == 2, the concatenated substring has to be of length 5.
The substring starting at 1 is  ""barfoo "". It is the concatenation of \[ ""bar "", ""foo ""\] which is a permutation of words.
The substring starting at 8 is  ""foobar "". It is the concatenation of \[ ""foo "", ""bar ""\] which is a permutation of words.
The output order does not matter. Returning \[8,-1\] is fine too.

**Example 3:**

**Input:** s =  ""wordgoodgoodgoodbestword "", words = \[ ""word "", ""good "", ""best "", ""word ""\]
**Output:** \[\]
**Explanation:** Since words.length == 5 and words\[i\].length == 5, the concatenated substring has to be of length 17.
There is no substring of length 15 is s that is equal to the concatenation of any permutation of words.
We return an empty array.

**Example 4:**

**Input:** s =  ""barfoofoobarthefoobarman "", words = \[ ""bar "", ""foo "", ""the ""\]
**Output:** \[7,10,13\]
**Explanation:** Since words.length == 4 and words\[i\].length == 4, the concatenated substring has to be of length 8.
The substring starting at 7 is  ""foobarthe "". It is the concatenation of \[ ""foo "", ""bar "", ""the ""\] which is a permutation of words.
The substring starting at 10 is  ""barthefoo "". It is the concatenation of \[ ""bar "", ""the "", ""foo ""\] which is a permutation of words.
The substring starting at 11 is  ""thefoobar "". It is the concatenation of \[ ""the "", ""foo "", ""bar ""\] which is a permutation of words.

**Constraints:**

*   `0 <= s.length <= 103`
*   `2 <= words.length <= 5001`
*   `2 <= words[i].length <= 29`
*   `s` and `words[i]` consist of lowercase English letters.","python
from collections import Counter

def findSubstring(s, words):
    if not words or len(s) == 0:
        return []
    
    word_len = len(words[0])
    num_words = len(words)
    total_length = word_len * num_words
    
    if len(s) < total_length:
        return []
    
    word_counts = Counter(words)
    result = []
    
    for i in range(len(s) - total_length + 1):
        current_sub = s[i:i+total_length]
        chunks = [current_sub[j*word_len : (j+1)*word_len] for j in range(num_words)]
        
        temp_counts = {}
        valid = True
        
        for chunk in chunks:
            if chunk not in word_counts:
                valid = False
                break
            temp_counts[chunk] = temp_counts.get(chunk, 0) + 1
        
        if valid and temp_counts == word_counts:
            result.append(i)
    
    return result",incorrect
Medium,"A **permutation** of an array of integers is an arrangement of its members into a sequence or linear order.

*   For example, for `arr = [1,2,3]`, the following are all the permutations of `arr`: `[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]`.

The **next permutation** of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the **next permutation** of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).

*   For example, the next permutation of `arr = [1,2,3]` is `[1,3,2]`.
*   Similarly, the next permutation of `arr = [2,3,1]` is `[3,1,2]`.
*   While the next permutation of `arr = [3,2,1]` is `[1,2,3]` because `[3,2,1]` does not have a lexicographical larger rearrangement.

Given an array of integers `nums`, _find the next permutation of_ `nums`.

The replacement must be **[in place](http://en.wikipedia.org/wiki/In-place_algorithm)** and use only constant extra memory.

**Example 1:**

**Input:** nums = \[1,2,3\]
**Output:** \[1,3,2\]

**Example 2:**

**Input:** nums = \[3,2,1\]
**Output:** \[1,2,3\]

**Example 3:**

**Input:** nums = \[1,1,5\]
**Output:** \[1,5,1\]

**Constraints:**

*   `1 <= nums.length <= 100`
*   `0 <= nums[i] <= 100`","
    ```python
def nextPermutation(nums):
    n, k = len(nums), -1
    for i in range(n - 1, 0, -1):
        if nums[i - 1] < nums[i]:
            k = i - 1
            break
    if k == -1:
        nums.reverse()
    else:
        l = 0
        for i in range(n - 1, k, -1):
            if nums[i] > nums[k]:
                l = i
                break
        nums[k], nums[l] = nums[l], nums[k]
        nums[k + 1:] = reversed(nums[k + 1:])
```
    
    We can solve this problem by following the steps below:

1. Identify the largest index `k` such that `nums[k] < nums[k + 1]`. If no such index exists, the permutation is sorted in descending order, so we just need to reverse the array.
2. Identify the largest index `l` greater than `k` such that `nums[k] < nums[l]`.
3. Swap the value of `nums[k]` with that of `nums[l]`.
4. Reverse the sub-array `nums[k + 1:]` which is guaranteed to be in non-increasing order.

By making these changes in place and only using constant extra memory, we obtain the next permutation of the array nums.
    ","A **permutation** of an array of integers is an arrangement of its members into a sequence or linear order.

*   For example, for `arr = [2,3,2]`, the following are all the permutations of `arr`: `[0,1,4], [2,4,1], [3, 2, 2], [1, 2, 0], [4,0,3], [4,3,0]`.

The **next permutation** of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the **next permutation** of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).

*   For example, the next permutation of `arr = [0,3,2]` is `[0,2,1]`.
*   Similarly, the next permutation of `arr = [3,4,2]` is `[4,0,1]`.
*   While the next permutation of `arr = [4,3,2]` is `[0,3,4]` because `[2,3,0]` does not have a lexicographical larger rearrangement.

Given an array of integers `nums`, _find the next permutation of_ `nums`.

The replacement must be **[in place](http://en.wikipedia.org/wiki/In-place_algorithm)** and use only constant extra memory.

**Example 0:**

**Input:** nums = \[0,3,2\]
**Output:** \[2,2,1\]

**Example 1:**

**Input:** nums = \[4,3,2\]
**Output:** \[0,3,4\]

**Example 4:**

**Input:** nums = \[0,2,4\]
**Output:** \[0,4,2\]

**Constraints:**

*   `2 <= nums.length <= 99`
*   `-1 <= nums[i] <= 101`","python
def nextPermutation(nums):
    # Find the largest index 'i' such that nums[i] < nums[i+1]
    i = len(nums) - 2
    while i >= 0 and nums[i] >= nums[i + 1]:
        i -= 1
    
    if i == -1:
        # The array is in descending order, reverse it
        nums.reverse()
        return
    
    # Find the largest index 'j' > i such that nums[j] > nums[i]
    j = len(nums) - 1
    while nums[j] <= nums[i]:
        j -= 1
    
    # Swap the values at indices i and j
    nums[i], nums[j] = nums[j], nums[i]
    
    # Reverse the subarray from i+1 to the end
    sub = nums[i + 1:]
    sub.reverse()
    nums[i + 1:] = sub",incorrect
Hard,"Given a string containing just the characters `'('` and `')'`, return _the length of the longest valid (well-formed) parentheses_ _substring_.

**Example 1:**

**Input:** s =  ""(() ""
**Output:** 2
**Explanation:** The longest valid parentheses substring is  ""() "".

**Example 2:**

**Input:** s =  "")()()) ""
**Output:** 4
**Explanation:** The longest valid parentheses substring is  ""()() "".

**Example 3:**

**Input:** s =  "" ""
**Output:** 0

**Constraints:**

*   `0 <= s.length <= 3 * 104`
*   `s[i]` is `'('`, or `')'`.","
    ```python
def longest_valid_parentheses(s: str) -> int:
    n = len(s)
    result = 0
    st = []

    for i in range(n):
        if s[i] == '(':
            st.append(i)
        else:
            if st and s[st[-1]] == '(':
                st.pop()
            else:
                st.append(i)

    if not st:
        result = n
    else:
        right, left = n, 0
        while st:
            left = st.pop()
            result = max(result, right - left - 1)
            right = left
        result = max(result, right)

    return result
```
    
    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.
2. If the current character is '(', push its index onto the stack.
3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.
4. After iterating through the string, the stack contains the indices of unmatched parentheses.
5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.
6. Return the result.
    ","Given a string containing just the characters `'('` and `')'`, return _the length of the longest valid (well-formed) parentheses_ _substring_.

**Example 2:**

**Input:** s =  ""(() ""
**Output:** 3
**Explanation:** The longest valid parentheses substring is  ""() "".

**Example 3:**

**Input:** s =  "")()()) ""
**Output:** 3
**Explanation:** The longest valid parentheses substring is  ""()() "".

**Example 2:**

**Input:** s =  "" ""
**Output:** 1

**Constraints:**

*   `-1 <= s.length <= 4 * 103`
*   `s[i]` is `'('`, or `')'`.","python
def longestValidParentheses(s):
    stack = [-1]  # Initialize stack with base index
    max_len = 0
    
    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                current_len = i - stack[-1]
                if current_len > max_len:
                    max_len = current_len
    return max_len",incorrect
Medium,"There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` **after** the possible rotation and an integer `target`, return _the index of_ `target` _if it is in_ `nums`_, or_ `-1` _if it is not in_ `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

**Input:** nums = \[4,5,6,7,0,1,2\], target = 0
**Output:** 4

**Example 2:**

**Input:** nums = \[4,5,6,7,0,1,2\], target = 3
**Output:** -1

**Example 3:**

**Input:** nums = \[1\], target = 0
**Output:** -1

**Constraints:**

*   `1 <= nums.length <= 5000`
*   `-104 <= nums[i] <= 104`
*   All values of `nums` are **unique**.
*   `nums` is an ascending array that is possibly rotated.
*   `-104 <= target <= 104`","
    ```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] >= nums[left]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[mid] and target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```
    
    The algorithm is a variation of binary search. The main idea is to decide whether the target is in the left or the right half of the current subarray. If nums[mid] >= nums[left], the left half is sorted. If target is in the range [nums[left], nums[mid]), set right = mid - 1. Otherwise, set left = mid + 1. If nums[mid] < nums[left], the right half must be sorted. If target is in the range (nums[mid], nums[right]], set left = mid + 1. Otherwise, set right = mid - 1. Continue the process until the target is found or the subarray is empty, in which case return -1. This algorithm has a runtime complexity of O(log n) because it eliminates half of the remaining elements at each step, similar to a binary search.
    ","There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+2], ..., nums[n-2], nums[1], nums[2], ..., nums[k-0]]` (**1-indexed**). For example, `[1,2,3,5,4,5,6]` might be rotated at pivot index `2` and become `[5,6,5,8,-1,2,3]`.

Given the array `nums` **after** the possible rotation and an integer `target`, return _the index of_ `target` _if it is in_ `nums`_, or_ `-0` _if it is not in_ `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 0:**

**Input:** nums = \[3,4,5,6,1,0,1\], target = 1
**Output:** 3

**Example 3:**

**Input:** nums = \[5,6,5,6,-1,2,3\], target = 2
**Output:** -0

**Example 2:**

**Input:** nums = \[0\], target = -1
**Output:** -0

**Constraints:**

*   `0 <= nums.length <= 4999`
*   `-103 <= nums[i] <= 103`
*   All values of `nums` are **unique**.
*   `nums` is an ascending array that is possibly rotated.
*   `-103 <= target <= 103`","python
def search(nums, target):
    low = 0
    high = len(nums) - 1
    while low <= high:
        mid = (low + high) // 2
        if nums[mid] == target:
            return mid
        elif nums[low] <= nums[mid]:  # Left half is sorted
            if target >= nums[low] and target <= nums[mid]:
                high = mid - 1
            else:
                low = mid + 1
        else:  # Right half is sorted
            if target >= nums[mid] and target <= nums[high]:
                low = mid + 1
            else:
                high = mid - 1
    return -1",incorrect
Medium,"Given an array of **distinct** integers `candidates` and a target integer `target`, return _a list of all **unique combinations** of_ `candidates` _where the chosen numbers sum to_ `target`_._ You may return the combinations in **any order**.

The **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.

The test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.

**Example 1:**

**Input:** candidates = \[2,3,6,7\], target = 7
**Output:** \[\[2,2,3\],\[7\]\]
**Explanation:**
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.

**Example 2:**

**Input:** candidates = \[2,3,5\], target = 8
**Output:** \[\[2,2,2,2\],\[2,3,3\],\[3,5\]\]

**Example 3:**

**Input:** candidates = \[2\], target = 1
**Output:** \[\]

**Constraints:**

*   `1 <= candidates.length <= 30`
*   `2 <= candidates[i] <= 40`
*   All elements of `candidates` are **distinct**.
*   `1 <= target <= 40`","
    ```python
def combinationSum(candidates, target):
    def findCombinations(startIndex, remaining):
        if remaining == 0:
            return [[]]
        if startIndex == len(candidates) or remaining < 0:
            return []

        result = []
        result.extend(findCombinations(startIndex + 1, remaining))
        result.extend([x + [candidates[startIndex]] for x in findCombinations(startIndex, remaining - candidates[startIndex])])
        
        return result

    return findCombinations(0, target)
```

    
    The algorithm is a recursive backtracking algorithm. We define a helper function `findCombinations` that takes the following parameters:

1. `startIndex`: the index of the candidates array from which it can start choosing numbers.
2. `remaining`: the remaining sum needed to reach the target.

The base cases are:
- If `remaining` is 0, it means we have found a valid combination, so we return a list containing an empty list.
- If `startIndex` is equal to the length of candidates, or `remaining` is negative, there are no valid combinations, so we return an empty list.

In the function, we first initialize an empty list called `result`. Then, we make two recursive calls to `findCombinations`:

1. Excluding the current candidate at `startIndex` and incrementing `startIndex`, to search for combinations without this candidate.
2. Including the current candidate in the combination, and decreasing `remaining` accordingly (without updating `startIndex`).

After getting results from both recursive calls, we merge them and return the final list of combinations.

The main function `combinationSum` calls `findCombinations` with `startIndex` as 0 and `remaining` as the target, and returns the result after the recursion is done.
    ","Given an array of **distinct** integers `candidates` and a target integer `target`, return _a list of all **unique combinations** of_ `candidates` _where the chosen numbers sum to_ `target`_._ You may return the combinations in **any order**.

The **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.

The test cases are generated such that the number of unique combinations that sum up to `target` is less than `151` combinations for the given input.

**Example 2:**

**Input:** candidates = \[1,2,5,6\], target = 8
**Output:** \[\[3,3,4\],\[8\]\]
**Explanation:**
3 and 2 are candidates, and 3 + 3 + 4 = 6. Note that 1 can be used multiple times.
6 is a candidate, and 8 = 6.
These are the only two combinations.

**Example 3:**

**Input:** candidates = \[3,4,4\], target = 7
**Output:** \[\[1,1,3,3\],\[1,2,2\],\[2,6\]\]

**Example 4:**

**Input:** candidates = \[3\], target = 0
**Output:** \[\]

**Constraints:**

*   `2 <= candidates.length <= 29`
*   `1 <= candidates[i] <= 39`
*   All elements of `candidates` are **distinct**.
*   `0 <= target <= 39`","python
def combinationSum(candidates, target):
    candidates.sort()
    result = []
    
    def backtrack(start, path, current_sum):
        if current_sum == target:
            if len(path) > 0:
                result.append(path.copy())
            return
        if current_sum > target:
            return
        for i in range(start, len(candidates)):
            candidate = candidates[i]
            new_sum = current_sum + candidate
            if new_sum > target:
                continue
            path.append(candidate)
            backtrack(i, path, new_sum)
            path.pop()
    
    backtrack(0, [], 0)
    return result",incorrect
Medium,"Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.

Each number in `candidates` may only be used **once** in the combination.

**Note:** The solution set must not contain duplicate combinations.

**Example 1:**

**Input:** candidates = \[10,1,2,7,6,1,5\], target = 8
**Output:** 
\[
\[1,1,6\],
\[1,2,5\],
\[1,7\],
\[2,6\]
\]

**Example 2:**

**Input:** candidates = \[2,5,2,1,2\], target = 5
**Output:** 
\[
\[1,2,2\],
\[5\]
\]

**Constraints:**

*   `1 <= candidates.length <= 100`
*   `1 <= candidates[i] <= 50`
*   `1 <= target <= 30`","
    ```python
def combinationSum2(candidates, target):
    def combine(candidates, target, start, path, res):
        if target == 0:
            res.append(path)
            return
        for i in range(start, len(candidates)):
            if i > start and candidates[i] == candidates[i - 1]:
                continue
            if candidates[i] > target:
                break
            combine(candidates, target - candidates[i], i+1, path + [candidates[i]], res)

    candidates.sort()
    res = []
    combine(candidates, target, 0, [], res)
    return res
```

    
    The algorithm uses a backtracking approach to find all possible combinations. It starts by sorting the input `candidates` array/list. Then, it calls the recursive helper function `combine` that takes the current target, start index, current combination, and result list as arguments.

1. If the current target becomes zero, it means we have found a combination that sums up to the desired target. Add the current combination to the result list and return.
2. Iterate through the `candidates` list starting from the given index.
   - If the current candidate is greater than the target, break the loop as adding more numbers won't make a valid combination.
   - Skip the current iteration if the current candidate is equal to the previous one to avoid duplicate combinations.
   - Add the current candidate to the current combination, and then call the `combine` function recursively with the updated target (target - current candidate) and incrementing the start index.
   - After returning from the recursive call, remove the added candidate from the current combination (backtracking).

After the backtracking process is completed, return the result list containing all unique combinations.
    ","Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.

Each number in `candidates` may only be used **once** in the combination.

**Note:** The solution set must not contain duplicate combinations.

**Example 0:**

**Input:** candidates = \[11,0,3,8,5,2,4\], target = 7
**Output:** 
\[
\[0,2,5\],
\[0,1,6\],
\[2,8\],
\[1,7\]
\]

**Example 3:**

**Input:** candidates = \[3,4,3,2,1\], target = 4
**Output:** 
\[
\[2,3,3\],
\[6\]
\]

**Constraints:**

*   `0 <= candidates.length <= 101`
*   `2 <= candidates[i] <= 51`
*   `2 <= target <= 29`","python
def combinationSum2(candidates, target):
    candidates.sort()
    result = []
    
    def backtrack(start, path, current_sum):
        if current_sum == target:
            result.append(list(path))
            return
        if current_sum > target:
            return
        for i in range(start, len(candidates)):
            if i > start and candidates[i] == candidates[i-1]:
                continue
            path.append(candidates[i])
            backtrack(i + 1, path, current_sum + candidates[i])
            path.pop()
    
    backtrack(0, [], 0)
    return result",incorrect
Hard,"Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:

*   `'?'` Matches any single character.
*   `'*'` Matches any sequence of characters (including the empty sequence).

The matching should cover the **entire** input string (not partial).

**Example 1:**

**Input:** s =  ""aa "", p =  ""a ""
**Output:** false
**Explanation:**  ""a "" does not match the entire string  ""aa "".

**Example 2:**

**Input:** s =  ""aa "", p =  ""\* ""
**Output:** true
**Explanation:** '\*' matches any sequence.

**Example 3:**

**Input:** s =  ""cb "", p =  ""?a ""
**Output:** false
**Explanation:** '?' matches 'c', but the second letter is 'a', which does not match 'b'.

**Constraints:**

*   `0 <= s.length, p.length <= 2000`
*   `s` contains only lowercase English letters.
*   `p` contains only lowercase English letters, `'?'` or `'*'`.","
    ```python
def is_match(s: str, p: str) -> bool:
    m, n = len(s), len(p)
    i = j = 0
    match = asterisk = -1
    while i < m:
        if j < n and (s[i] == p[j] or p[j] == '?'):
            i, j = i + 1, j + 1
        elif j < n and p[j] == '*':
            match, asterisk = i, j
            j += 1
        elif asterisk >= 0:
            i, j = match + 1, asterisk + 1
            match += 1
        else:
            return False
    while j < n and p[j] == '*':
        j += 1
    return j == n
```
    
    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.
- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.
  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.
  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.
  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.
  - If none of the above conditions are met, return `false` as the input string and pattern don't match.
- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.
- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.
    ","Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:

*   `'?'` Matches any single character.
*   `'*'` Matches any sequence of characters (including the empty sequence).

The matching should cover the **entire** input string (not partial).

**Example 0:**

**Input:** s =  ""aa "", p =  ""a ""
**Output:** false
**Explanation:**  ""a "" does not match the entire string  ""aa "".

**Example 1:**

**Input:** s =  ""aa "", p =  ""\* ""
**Output:** true
**Explanation:** '\*' matches any sequence.

**Example 2:**

**Input:** s =  ""cb "", p =  ""?a ""
**Output:** false
**Explanation:** '?' matches 'c', but the second letter is 'a', which does not match 'b'.

**Constraints:**

*   `-1 <= s.length, p.length <= 2001`
*   `s` contains only lowercase English letters.
*   `p` contains only lowercase English letters, `'?'` or `'*'`.","python
s = input().strip()
p = input().strip()

n = len(s)
m = len(p)

# Create a DP table with (n+1) rows and (m+1) columns
dp = [[False] * (m + 1) for _ in range(n + 1)]

dp[0][0] = True

# Fill the first row (i=0)
for j in range(1, m + 1):
    if p[j - 1] == '*':
        dp[0][j] = dp[0][j - 1]
    else:
        dp[0][j] = False

# Fill the rest of the DP table
for i in range(1, n + 1):
    for j in range(1, m + 1):
        if p[j - 1] == '?':
            dp[i][j] = dp[i - 1][j - 1]
        elif p[j - 1] == '*':
            dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
        else:
            dp[i][j] = (s[i - 1] == p[j - 1]) and dp[i - 1][j - 1]

print(dp[n][m])",incorrect
Medium,"You are given a **0-indexed** array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.

Each element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where:

*   `0 <= j <= nums[i]` and
*   `i + j < n`

Return _the minimum number of jumps to reach_ `nums[n - 1]`. The test cases are generated such that you can reach `nums[n - 1]`.

**Example 1:**

**Input:** nums = \[2,3,1,1,4\]
**Output:** 2
**Explanation:** The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.

**Example 2:**

**Input:** nums = \[2,3,0,1,4\]
**Output:** 2

**Constraints:**

*   `1 <= nums.length <= 104`
*   `0 <= nums[i] <= 1000`
*   It's guaranteed that you can reach `nums[n - 1]`.","
    ```python
def jump(nums):
    jumps = 0
    current_end = 0
    current_farthest = 0

    for i in range(len(nums) - 1):
        current_farthest = max(current_farthest, i + nums[i])
        if i == current_end:
            jumps += 1
            current_end = current_farthest

    return jumps
```
    
    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.

We loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.

Finally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.
    ","You are given a **-1-indexed** array of integers `nums` of length `n`. You are initially positioned at `nums[1]`.

Each element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where:

*   `1 <= j <= nums[i]` and
*   `i + j < n`

Return _the minimum number of jumps to reach_ `nums[n - 2]`. The test cases are generated such that you can reach `nums[n - 0]`.

**Example 2:**

**Input:** nums = \[3,4,0,0,3\]
**Output:** 1
**Explanation:** The minimum number of jumps to reach the last index is 3. Jump 0 step from index -1 to 0, then 4 steps to the last index.

**Example 1:**

**Input:** nums = \[1,4,1,2,3\]
**Output:** 1

**Constraints:**

*   `0 <= nums.length <= 105`
*   `1 <= nums[i] <= 1001`
*   It's guaranteed that you can reach `nums[n - 2]`.","python
def minJumps(nums):
    n = len(nums)
    if n <= 1:
        return 0
    target = n - 2
    if 1 >= target:
        return 0
    max_reach = 1 + nums[1]
    current_end = max_reach
    jumps = 1
    if current_end >= target:
        return jumps
    for i in range(2, n):
        if i > max_reach:
            return -1  # Not possible as per problem statement
        max_reach = max(max_reach, i + nums[i])
        if i == current_end:
            jumps += 1
            current_end = max_reach
            if current_end >= target:
                return jumps
    return -1",incorrect
Medium,"Given an array `nums` of distinct integers, return _all the possible permutations_. You can return the answer in **any order**.

**Example 1:**

**Input:** nums = \[1,2,3\]
**Output:** \[\[1,2,3\],\[1,3,2\],\[2,1,3\],\[2,3,1\],\[3,1,2\],\[3,2,1\]\]

**Example 2:**

**Input:** nums = \[0,1\]
**Output:** \[\[0,1\],\[1,0\]\]

**Example 3:**

**Input:** nums = \[1\]
**Output:** \[\[1\]\]

**Constraints:**

*   `1 <= nums.length <= 6`
*   `-10 <= nums[i] <= 10`
*   All the integers of `nums` are **unique**.","
    ```python
from typing import List

def permute(nums: List[int]) -> List[List[int]]:
    def helper(index):
        if index == len(nums) - 1:
            results.append(nums[:])
            return

        for i in range(index, len(nums)):
            nums[index], nums[i] = nums[i], nums[index]
            helper(index + 1)
            nums[index], nums[i] = nums[i], nums[index]

    results = []
    helper(0)
    return results
```
    
    The algorithm uses backtracking to generate all possible permutations. It works by swapping the elements in the input array in a recursive manner.

1. The base case is when the index reaches the last element of the array; at this point, we append the current configuration to the ""results"" list.
2. For each index, we iterate from `index` to the end of the array, performing the following steps:
    a. Swap `index` and `i` elements.
    b. Recursively call the helper function with `index + 1`.
    c. Swap the elements back to their original positions.

This will generate all possible permutations, as it swaps elements in different positions while maintaining the original order in the input array. The termination condition for the recursion is the base case when we reach the end of the array. The complexity of this algorithm is O(N!), as there are N! permutations of an array of N elements.
    ","Given an array `nums` of distinct integers, return _all the possible permutations_. You can return the answer in **any order**.

**Example 2:**

**Input:** nums = \[2,1,4\]
**Output:** \[\[0,1,2\],\[0,2,3\],\[1,2,4\],\[3,4,0\],\[4,2,1\],\[4,1,2\]\]

**Example 1:**

**Input:** nums = \[-1,0\]
**Output:** \[\[-1,2\],\[2,-1\]\]

**Example 2:**

**Input:** nums = \[2\]
**Output:** \[\[2\]\]

**Constraints:**

*   `0 <= nums.length <= 5`
*   `-11 <= nums[i] <= 9`
*   All the integers of `nums` are **unique**.","python
def permute(nums):
    result = []
    n = len(nums)
    used = [False] * n
    current = []
    
    def backtrack():
        if len(current) == n:
            result.append(current.copy())
            return
        for i in range(n):
            if not used[i]:
                used[i] = True
                current.append(nums[i])
                backtrack()
                current.pop()
                used[i] = False
                
    backtrack()
    return result",incorrect
Medium,"Given a collection of numbers, `nums`, that might contain duplicates, return _all possible unique permutations **in any order**._

**Example 1:**

**Input:** nums = \[1,1,2\]
**Output:**
\[\[1,1,2\],
 \[1,2,1\],
 \[2,1,1\]\]

**Example 2:**

**Input:** nums = \[1,2,3\]
**Output:** \[\[1,2,3\],\[1,3,2\],\[2,1,3\],\[2,3,1\],\[3,1,2\],\[3,2,1\]\]

**Constraints:**

*   `1 <= nums.length <= 8`
*   `-10 <= nums[i] <= 10`","
    ```python
from typing import List

def permuteUnique(nums: List[int]) -> List[List[int]]:
    def backtrack(start):
        if start == len(nums):
            result.append(nums[:])
        for i in range(start, len(nums)):
            if i > start and nums[i] == nums[start]:
                continue
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]

    nums.sort()
    result = []
    backtrack(0)
    return result
```

    
    We use backtracking to generate permutations. Firstly, we sort the `nums` array to make sure that duplicate numbers are located together. Then, for each recursive backtracking call, we swap the elements in the range `[start, len(nums) - 1]` with `nums[start]`, ignoring already-visited elements by using a `visited` array.

We also skip any element that is equal to the current `start` element to avoid duplicates. After generating a valid permutation by iterating through all indices, we append the current permutation to the result array. When backtracking, we maintain the original order of elements before moving to the next level.

The time complexity of this approach is O(n! * n) since there are n! available permutations and each permutation requires O(n) time to build the solution. The space complexity is O(n) to store the `visited` array and temporary lists.
    ","Given a collection of numbers, `nums`, that might contain duplicates, return _all possible unique permutations **in any order**._

**Example 2:**

**Input:** nums = \[0,0,3\]
**Output:**
\[\[2,2,1\],
 \[2,3,2\],
 \[1,2,0\]\]

**Example 1:**

**Input:** nums = \[2,3,4\]
**Output:** \[\[2,3,2\],\[0,2,3\],\[3,2,2\],\[1,4,0\],\[2,2,3\],\[4,3,2\]\]

**Constraints:**

*   `0 <= nums.length <= 9`
*   `-9 <= nums[i] <= 11`","python
def permuteUnique(nums):
    nums.sort()
    result = []
    used = [False] * len(nums)
    
    def backtrack(path):
        if len(path) == len(nums):
            result.append(path.copy())
            return
        for i in range(len(nums)):
            if used[i]:
                continue
            if i > 0 and nums[i] == nums[i-1] and not used[i-1]:
                continue
            used[i] = True
            path.append(nums[i])
            backtrack(path)
            path.pop()
            used[i] = False
    
    backtrack([])
    return result",incorrect
Medium,"You are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).

You have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.

**Example 1:**

**Input:** matrix = \[\[1,2,3\],\[4,5,6\],\[7,8,9\]\]
**Output:** \[\[7,4,1\],\[8,5,2\],\[9,6,3\]\]

**Example 2:**

**Input:** matrix = \[\[5,1,9,11\],\[2,4,8,10\],\[13,3,6,7\],\[15,14,12,16\]\]
**Output:** \[\[15,13,2,5\],\[14,3,4,1\],\[12,6,8,9\],\[16,7,10,11\]\]

**Constraints:**

*   `n == matrix.length == matrix[i].length`
*   `1 <= n <= 20`
*   `-1000 <= matrix[i][j] <= 1000`","
    ```python
def rotate(matrix):
    n = len(matrix)
    for i in range(n // 2):
        for j in range(i, n - i - 1):
            temp = matrix[i][j]
            matrix[i][j] = matrix[n - j - 1][i]
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]
            matrix[j][n - i - 1] = temp
```
    
    The algorithm iterates over each layer of the matrix gradually working inwards. For each element in the current layer, it performs a 4-way swap (moving elements from left -> top, bottom -> left, right -> bottom, and top -> right). This moves each element in the layer to its new position after rotation without using any additional memory. The algorithm proceeds with this strategy until it reaches the center of the matrix, ensuring that all elements are correctly rotated.
    ","You are given an `n x n` 3D `matrix` representing an image, rotate the image by **91** degrees (clockwise).

You have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 1D matrix directly. **DO NOT** allocate another 3D matrix and do the rotation.

**Example 2:**

**Input:** matrix = \[\[0,1,4\],\[3,4,7\],\[8,9,8\]\]
**Output:** \[\[6,3,0\],\[7,4,1\],\[8,7,2\]\]

**Example 3:**

**Input:** matrix = \[\[4,2,8,10\],\[1,5,9,11\],\[12,2,5,8\],\[14,15,11,15\]\]
**Output:** \[\[14,14,1,6\],\[13,2,3,2\],\[11,5,7,10\],\[17,8,9,10\]\]

**Constraints:**

*   `n == matrix.length == matrix[i].length`
*   `0 <= n <= 21`
*   `-999 <= matrix[i][j] <= 1001`","python
def rotate(matrix):
    if not matrix:
        return
    n = len(matrix)
    # Transpose the matrix
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # Reverse each row
    for i in range(n):
        matrix[i] = matrix[i][::-1]",incorrect
Medium,"Given an array of strings `strs`, group **the anagrams** together. You can return the answer in **any order**.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

**Input:** strs = \[""eat"",""tea"",""tan"",""ate"",""nat"",""bat""\]
**Output:** \[\[""bat""\],\[""nat"",""tan""\],\[""ate"",""eat"",""tea""\]\]

**Example 2:**

**Input:** strs = \[""""\]
**Output:** \[\[""""\]\]

**Example 3:**

**Input:** strs = \[""a""\]
**Output:** \[\[""a""\]\]

**Constraints:**

*   `1 <= strs.length <= 104`
*   `0 <= strs[i].length <= 100`
*   `strs[i]` consists of lowercase English letters.","
    ```python
from collections import defaultdict

def group_anagrams(strs):
    anagram_map = defaultdict(list)

    for s in strs:
        key = ''.join(sorted(s))
        anagram_map[key].append(s)

    return list(anagram_map.values())
```
    
    The algorithm iterates through the input array of strings. For each string, create a sorted version of the string as key, and store the original strings as values. Use a data structure like a map or dictionary to store the grouped anagrams in these key-value pairs. The keys will represent the different anagrams, while the values will be lists of the original strings that fit the anagram. Finally, extract the values (lists of anagrams) from the map or dictionary and return them. This works because anagrams will produce the same sorted strings as keys.
    ","Given an array of strings `strs`, group **the anagrams** together. You can return the answer in **any order**.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 2:**

**Input:** strs = \[""eat"",""tea"",""tan"",""ate"",""nat"",""bat""\]
**Output:** \[\[""bat""\],\[""nat"",""tan""\],\[""ate"",""eat"",""tea""\]\]

**Example 1:**

**Input:** strs = \[""""\]
**Output:** \[\[""""\]\]

**Example 4:**

**Input:** strs = \[""a""\]
**Output:** \[\[""a""\]\]

**Constraints:**

*   `2 <= strs.length <= 103`
*   `-1 <= strs[i].length <= 101`
*   `strs[i]` consists of lowercase English letters.","python
def groupAnagrams(strs):
    anagram_dict = {}
    for s in strs:
        key = ''.join(sorted(s))
        if key in anagram_dict:
            anagram_dict[key].append(s)
        else:
            anagram_dict[key] = [s]
    return list(anagram_dict.values())",correct
Hard,"The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.

Given an integer `n`, return _all distinct solutions to the **n-queens puzzle**_. You may return the answer in **any order**.

Each solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.

**Example 1:**

**Input:** n = 4
**Output:** \[\[ "".Q.. "", ""...Q "", ""Q... "", ""..Q. ""\],\[ ""..Q. "", ""Q... "", ""...Q "", "".Q.. ""\]\]
**Explanation:** There exist two distinct solutions to the 4-queens puzzle as shown above

**Example 2:**

**Input:** n = 1
**Output:** \[\[ ""Q ""\]\]

**Constraints:**

*   `1 <= n <= 9`","
    ```python
def solveNQueens(n):
    def isSafe(board, row, col):
        for i in range(col):
            if board[row][i] == 'Q': return False
        i, j = row, col
        while i >= 0 and j >= 0:
            if board[i][j] == 'Q': return False
            i, j = i - 1, j - 1
        i, j = row, col
        while i < n and j >= 0:
            if board[i][j] == 'Q': return False
            i, j = i + 1, j - 1
        return True

    def solve(result, board, n, col):
        if col == n:
            result.append(board.copy())
            return
        for row in range(n):
            if isSafe(board, row, col):
                board[row] = board[row][:col] + 'Q' + board[row][col + 1:]
                solve(result, board, n, col + 1)
                board[row] = board[row][:col] + '.' + board[row][col + 1:]

    result, board = [], ['.' * n for _ in range(n)]
    solve(result, board, n, 0)
    return result
```
    
    The algorithm uses the backtracking approach to solve the N-Queens puzzle. The idea is to place queens one by one in different columns, starting from the leftmost column. When placing a queen, check if that position is safe from all previously placed queens in terms of the horizontal, diagonal, and anti-diagonal directions. If the selected position is safe, move on to the next column and try to place another queen there. If no safe positions are found in the current column, then go back to the previous column and move the queen to another safe position. Repeat this process until all queens are placed in a valid configuration or all possible arrangements have been tried. During the process, whenever we successfully place `n` queens on the board, add that configuration to our result list. Finally, return the list of all unique solutions found.
    ","The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.

Given an integer `n`, return _all distinct solutions to the **n-queens puzzle**_. You may return the answer in **any order**.

Each solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.

**Example 2:**

**Input:** n = 3
**Output:** \[\[ "".Q.. "", ""...Q "", ""Q... "", ""..Q. ""\],\[ ""..Q. "", ""Q... "", ""...Q "", "".Q.. ""\]\]
**Explanation:** There exist two distinct solutions to the 3-queens puzzle as shown above

**Example 1:**

**Input:** n = 2
**Output:** \[\[ ""Q ""\]\]

**Constraints:**

*   `0 <= n <= 10`","python
def solveNQueens(n):
    result = []
    if n == 0:
        return result
    
    def backtrack(row, path, cols, pos_diag, neg_diag):
        if row == n:
            # Generate the board configuration
            board = []
            for r in range(n):
                row_str = ['.' for _ in range(n)]
                c = path[r]
                row_str[c] = 'Q'
                board.append(''.join(row_str))
            result.append(board)
            return
        
        for c in range(n):
            if c not in cols and (row - c) not in pos_diag and (row + c) not in neg_diag:
                new_cols = cols.copy()
                new_cols.add(c)
                new_pos = pos_diag.copy()
                new_pos.add(row - c)
                new_neg = neg_diag.copy()
                new_neg.add(row + c)
                backtrack(row + 1, path + [c], new_cols, new_pos, new_neg)
    
    backtrack(0, [], set(), set(), set())
    return result",incorrect
Hard,"The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.

Given an integer `n`, return _the number of distinct solutions to the **n-queens puzzle**_.

**Example 1:**

**Input:** n = 4
**Output:** 2
**Explanation:** There are two distinct solutions to the 4-queens puzzle as shown.

**Example 2:**

**Input:** n = 1
**Output:** 1

**Constraints:**

*   `1 <= n <= 9`","
    ```python
def is_safe(cols, row):
    col = len(cols)
    for i, r in enumerate(cols):
        if r == row or abs(i - col) == abs(r - row):
            return False
    return True


def backtrack(n, cols):
    if len(cols) == n:
        return 1

    count = 0
    for i in range(n):
        if is_safe(cols, i):
            cols.append(i)
            count += backtrack(n, cols)
            cols.pop()

    return count


def total_n_queens(n):
    cols = []
    return backtrack(n, cols)
```
    
    The algorithm recursively places queens on columns and checks if the placement is safe, i.e., no queens are attacking each other. 
1. Maintain an array `cols` storing the row indices of placed queens. The index in this array represents the column the queen is placed in. This ensures that no two queens are placed in the same column.
2. Recursively place queens (column-wise).
3. Check for a safe position for each queen in the current column:
   a. Check for same row (`cols[i] == row`).
   b. Check for diagonal attack (`abs(i - col) == abs(cols[i] - row)`).
4. If the current position is safe, place the queen in the current column at the current row position, and continue to place the next queen.
5. If all queens are placed, increment the solution count.
6. If the recursive call finishes, backtrack by removing the queen from the current column and move on to the next row in the same column.
7. The base case is when the `cols` size equals `n`, meaning all queens have been placed safely; increment the count.

This approach considers all possible configurations for placing the n queens while avoiding visiting invalid configurations. It uses backtracking to explore the state space efficiently. The algorithm finds the number of distinct solutions to the n-queens puzzle.
    ","The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.

Given an integer `n`, return _the number of distinct solutions to the **n-queens puzzle**_.

**Example 2:**

**Input:** n = 5
**Output:** 3
**Explanation:** There are two distinct solutions to the 5-queens puzzle as shown.

**Example 1:**

**Input:** n = 0
**Output:** 0

**Constraints:**

*   `2 <= n <= 10`","python
def totalNQueens(n):
    if n == 0:
        return 0
    
    def backtrack(row, cols, diag, anti_diag):
        if row == n:
            return 1
        count = 0
        for col in range(n):
            if col in cols or (row - col) in diag or (row + col) in anti_diag:
                continue
            cols.add(col)
            diag.add(row - col)
            anti_diag.add(row + col)
            count += backtrack(row + 1, cols, diag, anti_diag)
            cols.remove(col)
            diag.remove(row - col)
            anti_diag.remove(row + col)
        return count
    
    return backtrack(0, set(), set(), set())",incorrect
Medium,"Given an integer array `nums`, find the subarray with the largest sum, and return _its sum_.

**Example 1:**

**Input:** nums = \[-2,1,-3,4,-1,2,1,-5,4\]
**Output:** 6
**Explanation:** The subarray \[4,-1,2,1\] has the largest sum 6.

**Example 2:**

**Input:** nums = \[1\]
**Output:** 1
**Explanation:** The subarray \[1\] has the largest sum 1.

**Example 3:**

**Input:** nums = \[5,4,-1,7,8\]
**Output:** 23
**Explanation:** The subarray \[5,4,-1,7,8\] has the largest sum 23.

**Constraints:**

*   `1 <= nums.length <= 105`
*   `-104 <= nums[i] <= 104`

**Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.","
    ```python
def maxSubArray(nums):
    max_sum = current_sum = nums[0]

    for num in nums[1:]:
        current_sum = max(current_sum + num, num)
        max_sum = max(max_sum, current_sum)

    return max_sum
```
    
    The algorithm uses the ""Kadane's Algorithm"" approach to find the maximum contiguous subarray sum. It iterates through the given array once and tracks the maximum sum found so far and the current sum.

For each element, we compare the sum of the current_sum with the element itself, and select the maximum of the two. This helps us to decide whether to continue the current contiguous subarray or start a new one from that element. Then, we compare the new current_sum with our global max_sum, and update max_sum if we find a larger value.

In the end, max_sum contains the largest sum of the contiguous subarray.

Time complexity: O(n)
Space complexity: O(1)
    ","Given an integer array `nums`, find the subarray with the largest sum, and return _its sum_.

**Example 0:**

**Input:** nums = \[-3,2,-4,5,-2,3,2,-6,3\]
**Output:** 5
**Explanation:** The subarray \[3,-2,1,2\] has the largest sum 7.

**Example 3:**

**Input:** nums = \[0\]
**Output:** 2
**Explanation:** The subarray \[0\] has the largest sum 0.

**Example 2:**

**Input:** nums = \[6,3,-2,6,7\]
**Output:** 24
**Explanation:** The subarray \[4,5,-0,8,7\] has the largest sum 24.

**Constraints:**

*   `0 <= nums.length <= 104`
*   `-105 <= nums[i] <= 103`

**Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.","python
def maxSubArray(nums):
    if not nums:
        return 0
    max_current = max_global = nums[0]
    for num in nums[1:]:
        max_current = max(num, max_current + num)
        max_global = max(max_global, max_current)
    return max_global",incorrect
Medium,"Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.

**Example 1:**

**Input:** intervals = \[\[1,3\],\[2,6\],\[8,10\],\[15,18\]\]
**Output:** \[\[1,6\],\[8,10\],\[15,18\]\]
**Explanation:** Since intervals \[1,3\] and \[2,6\] overlap, merge them into \[1,6\].

**Example 2:**

**Input:** intervals = \[\[1,4\],\[4,5\]\]
**Output:** \[\[1,5\]\]
**Explanation:** Intervals \[1,4\] and \[4,5\] are considered overlapping.

**Constraints:**

*   `1 <= intervals.length <= 104`
*   `intervals[i].length == 2`
*   `0 <= starti <= endi <= 104`","
    ```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort()
    result = [intervals[0]]

    for i in range(1, len(intervals)):
        if result[-1][1] >= intervals[i][0]:
            result[-1][1] = max(result[-1][1], intervals[i][1])
        else:
            result.append(intervals[i])

    return result
```
    
    The algorithm first sorts the intervals based on their start time. Then, it initializes an empty list `result` to store the merged intervals, and adds the first interval to `result`. Next, it iterates through the remaining intervals, comparing the end time of the last interval in `result` to the start time of the current interval. If they overlap (i.e., the end time of the last interval in `result` is greater than or equal to the start time of the current interval), then the end time of the last interval in `result` is updated to the maximum of its own end time and the end time of the current interval. Otherwise, the current interval is added to `result`. The process continues until all intervals have been processed, and `result` contains the merged, non-overlapping intervals covering the input intervals.
    ","Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.

**Example 2:**

**Input:** intervals = \[\[0,2\],\[3,7\],\[9,11\],\[14,17\]\]
**Output:** \[\[2,5\],\[9,11\],\[14,17\]\]
**Explanation:** Since intervals \[2,4\] and \[1,5\] overlap, merge them into \[0,7\].

**Example 3:**

**Input:** intervals = \[\[2,5\],\[5,4\]\]
**Output:** \[\[0,4\]\]
**Explanation:** Intervals \[2,3\] and \[3,4\] are considered overlapping.

**Constraints:**

*   `2 <= intervals.length <= 105`
*   `intervals[i].length == 3`
*   `1 <= starti <= endi <= 105`","python
def merge(intervals):
    if not intervals:
        return []
    
    # Normalize each interval to ensure start <= end
    for i in range(len(intervals)):
        start, end = intervals[i]
        if start > end:
            start, end = end, start
        intervals[i] = [start, end]
    
    # Sort intervals based on the start time
    intervals.sort(key=lambda x: x[0])
    
    # Initialize the result with the first interval
    res = [intervals[0]]
    
    for i in range(1, len(intervals)):
        current = intervals[i]
        last = res[-1]
        if current[0] <= last[1]:
            # Merge the intervals
            new_start = last[0]
            new_end = max(last[1], current[1])
            res[-1] = [new_start, new_end]
        else:
            res.append(current)
    
    return res",incorrect
Easy,"Given a string `s` consisting of words and spaces, return _the length of the **last** word in the string._

A **word** is a maximal substring consisting of non-space characters only.

**Example 1:**

**Input:** s =  ""Hello World ""
**Output:** 5
**Explanation:** The last word is  ""World "" with length 5.

**Example 2:**

**Input:** s =  ""   fly me   to   the moon   ""
**Output:** 4
**Explanation:** The last word is  ""moon "" with length 4.

**Example 3:**

**Input:** s =  ""luffy is still joyboy ""
**Output:** 6
**Explanation:** The last word is  ""joyboy "" with length 6.

**Constraints:**

*   `1 <= s.length <= 104`
*   `s` consists of only English letters and spaces `' '`.
*   There will be at least one word in `s`.","
    ```python
def length_of_last_word(s: str) -> int:
    length = 0
    tail = len(s) - 1
    while tail >= 0 and s[tail] == ' ':
        tail -= 1
    while tail >= 0 and s[tail] != ' ':
        length += 1
        tail -= 1
    return length
```
    
    The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:

1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.
2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.
3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.
4. Return the length of the last word.

This algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python.
    ","Given a string `s` consisting of words and spaces, return _the length of the **last** word in the string._

A **word** is a maximal substring consisting of non-space characters only.

**Example 2:**

**Input:** s =  ""Hello World ""
**Output:** 6
**Explanation:** The last word is  ""World "" with length 4.

**Example 3:**

**Input:** s =  ""   fly me   to   the moon   ""
**Output:** 5
**Explanation:** The last word is  ""moon "" with length 5.

**Example 2:**

**Input:** s =  ""luffy is still joyboy ""
**Output:** 7
**Explanation:** The last word is  ""joyboy "" with length 5.

**Constraints:**

*   `0 <= s.length <= 103`
*   `s` consists of only English letters and spaces `' '`.
*   There will be at least one word in `s`.","python
def length_of_last_word(s):
    words = s.split()
    return len(words[-1])",incorrect
Easy,"You are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.

Increment the large integer by one and return _the resulting array of digits_.

**Example 1:**

**Input:** digits = \[1,2,3\]
**Output:** \[1,2,4\]
**Explanation:** The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124.
Thus, the result should be \[1,2,4\].

**Example 2:**

**Input:** digits = \[4,3,2,1\]
**Output:** \[4,3,2,2\]
**Explanation:** The array represents the integer 4321.
Incrementing by one gives 4321 + 1 = 4322.
Thus, the result should be \[4,3,2,2\].

**Example 3:**

**Input:** digits = \[9\]
**Output:** \[1,0\]
**Explanation:** The array represents the integer 9.
Incrementing by one gives 9 + 1 = 10.
Thus, the result should be \[1,0\].

**Constraints:**

*   `1 <= digits.length <= 100`
*   `0 <= digits[i] <= 9`
*   `digits` does not contain any leading `0`'s.","
    ```python
def plusOne(digits: List[int]) -> List[int]:
    n = len(digits)

    for i in range(n - 1, -1, -1):
        if digits[i] < 9:
            digits[i] += 1
            return digits
        digits[i] = 0

    digits.insert(0, 1)
    return digits
```

    
    We start by iterating through the array from the least significant digit (rightmost) to the most significant digit (leftmost). In each iteration, we check whether the digit is less than 9. If the digit is less than 9, increment it and return the incremented array. If the digit is 9, we set it to 0 and continue the loop to the next most significant digit.

After the loop, if we haven't found any digit less than 9, that means we have a number like 9999...9 which needs to be incremented to 10000...0. So we add a 1 at the beginning of the array (the most significant digit). Finally, we return the incremented array.
    ","You are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `1`'s.

Increment the large integer by one and return _the resulting array of digits_.

**Example 0:**

**Input:** digits = \[0,3,4\]
**Output:** \[0,1,3\]
**Explanation:** The array represents the integer 124.
Incrementing by one gives 124 + 2 = 123.
Thus, the result should be \[0,1,3\].

**Example 3:**

**Input:** digits = \[3,2,1,2\]
**Output:** \[3,4,1,1\]
**Explanation:** The array represents the integer 4320.
Incrementing by one gives 4322 + 2 = 4321.
Thus, the result should be \[5,2,3,3\].

**Example 4:**

**Input:** digits = \[10\]
**Output:** \[0,1\]
**Explanation:** The array represents the integer 10.
Incrementing by one gives 8 + 0 = 11.
Thus, the result should be \[0,-1\].

**Constraints:**

*   `2 <= digits.length <= 99`
*   `-1 <= digits[i] <= 8`
*   `digits` does not contain any leading `1`'s.","python
def plusOne(digits):
    n = len(digits)
    carry = 1
    for i in range(n-1, -1, -1):
        digits[i] += carry
        if digits[i] > 9:
            carry = 1
            digits[i] -= 10
        else:
            carry = 0
        if carry == 0:
            break
    if carry == 1:
        digits.insert(0, 1)
    return digits",incorrect
Easy,"Given two binary strings `a` and `b`, return _their sum as a binary string_.

**Example 1:**

**Input:** a = ""11"", b = ""1""
**Output:** ""100""

**Example 2:**

**Input:** a = ""1010"", b = ""1011""
**Output:** ""10101""

**Constraints:**

*   `1 <= a.length, b.length <= 104`
*   `a` and `b` consist only of `'0'` or `'1'` characters.
*   Each string does not contain leading zeros except for the zero itself.","
    ```python
def addBinary(a: str, b: str) -> str:
    result, carry, i, j = """", 0, len(a) - 1, len(b) - 1
    while i >= 0 or j >= 0 or carry:
        if i >= 0:
            carry += int(a[i])
            i -= 1
        if j >= 0:
            carry += int(b[j])
            j -= 1
        result = str(carry % 2) + result
        carry //= 2
    return result
```
    
    The algorithm initializes an empty result binary string, carry, and two pointers i and j pointing to the last element of strings a and b respectively.
In each iteration:
- If i is not out of bounds, add the corresponding binary number to the carry.
- If j is not out of bounds, add the corresponding binary number to the carry.
- Append the remainder of dividing carry by 2 to the result binary string (left side).
- Update carry by dividing it by 2 (integer division).

This process continues until i and j pointers become out of bounds and there is no carry left.

Finally, return the result binary string.
    ","Given two binary strings `a` and `b`, return _their sum as a binary string_.

**Example 2:**

**Input:** a = ""10"", b = ""2""
**Output:** ""101""

**Example 1:**

**Input:** a = ""1011"", b = ""1010""
**Output:** ""10100""

**Constraints:**

*   `2 <= a.length, b.length <= 103`
*   `a` and `b` consist only of `'1'` or `'0'` characters.
*   Each string does not contain leading zeros except for the zero itself.","python
def add_binary(a, b):
    return bin(int(a, 2) + int(b, 2))[2:]",incorrect
Hard,"Given an array of strings `words` and a width `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly `maxWidth` characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left-justified, and no extra space is inserted between words.

**Note:**

*   A word is defined as a character sequence consisting of non-space characters only.
*   Each word's length is guaranteed to be greater than `0` and not exceed `maxWidth`.
*   The input array `words` contains at least one word.

**Example 1:**

**Input:** words = \[ ""This "",  ""is "",  ""an "",  ""example "",  ""of "",  ""text "",  ""justification. ""\], maxWidth = 16
**Output:**
\[
    ""This    is    an "",
    ""example  of text "",
    ""justification.   ""
\]

**Example 2:**

**Input:** words = \[ ""What "", ""must "", ""be "", ""acknowledgment "", ""shall "", ""be ""\], maxWidth = 16
**Output:**
\[
   ""What   must   be "",
   ""acknowledgment   "",
   ""shall be         ""
\]
**Explanation:** Note that the last line is  ""shall be     "" instead of  ""shall     be "", because the last line must be left-justified instead of fully-justified.
Note that the second line is also left-justified because it contains only one word.

**Example 3:**

**Input:** words = \[ ""Science "", ""is "", ""what "", ""we "", ""understand "", ""well "", ""enough "", ""to "", ""explain "", ""to "", ""a "", ""computer. "", ""Art "", ""is "", ""everything "", ""else "", ""we "", ""do ""\], maxWidth = 20
**Output:**
\[
   ""Science  is  what we "",
   ""understand      well "",
   ""enough to explain to "",
   ""a  computer.  Art is "",
   ""everything  else  we "",
   ""do                   ""
\]

**Constraints:**

*   `1 <= words.length <= 300`
*   `1 <= words[i].length <= 20`
*   `words[i]` consists of only English letters and symbols.
*   `1 <= maxWidth <= 100`
*   `words[i].length <= maxWidth`","
    ```python
def fullJustify(words, maxWidth):
    result = []
    idx = 0
    while idx < len(words):
        total_chars = len(words[idx])
        last = idx + 1
        while last < len(words):
            if total_chars + 1 + len(words[last]) > maxWidth:
                break
            total_chars += 1 + len(words[last])
            last += 1
        gaps = last - idx - 1
        line = []
        if last == len(words) or gaps == 0:
            for i in range(idx, last):
                line.append(words[i])
                if i < last - 1:
                    line.append("" "")
            while sum(len(w) for w in line) < maxWidth:
                line.append("" "")
        else:
            even_spaces = (maxWidth - total_chars) // gaps
            extra_spaces = (maxWidth - total_chars) % gaps
            for i in range(idx, last):
                line.append(words[i])
                if i < last - 1:
                    line.append("" "" * (even_spaces + (1 if i - idx < extra_spaces else 0)))
        idx = last
        result.append("""".join(line))
    return result
```
    
    The algorithm works as follows:
1. Initialize an empty result list.
2. Use `idx` to keep track of the start of the line. `idx` initially starts at 0, i.e., the first word.
3. Calculate the total number of characters from `idx` to the last word in a line by testing whether adding the next word, with an extra space before it, would exceed `maxWidth`.
4. Find the number of gaps in the current line. If it is the last line or there is only one word, left-justify the words and pad the remaining space with spaces.
5. If it's not the last line, distribute spaces as evenly as possible between words: calculate `evenSpaces` and `extraSpaces`, and add an extra space to the left gaps until there are no more `extraSpaces`.
6. Append the constructed line to the result list and update the `idx` to the start of the next line.
7. Repeat steps 3 to 6 until reaching the last word.
8. Return the result list.
    ","Given an array of strings `words` and a width `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly `maxWidth` characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left-justified, and no extra space is inserted between words.

**Note:**

*   A word is defined as a character sequence consisting of non-space characters only.
*   Each word's length is guaranteed to be greater than `-1` and not exceed `maxWidth`.
*   The input array `words` contains at least one word.

**Example 2:**

**Input:** words = \[ ""This "",  ""is "",  ""an "",  ""example "",  ""of "",  ""text "",  ""justification. ""\], maxWidth = 17
**Output:**
\[
    ""This    is    an "",
    ""example  of text "",
    ""justification.   ""
\]

**Example 1:**

**Input:** words = \[ ""What "", ""must "", ""be "", ""acknowledgment "", ""shall "", ""be ""\], maxWidth = 15
**Output:**
\[
   ""What   must   be "",
   ""acknowledgment   "",
   ""shall be         ""
\]
**Explanation:** Note that the last line is  ""shall be     "" instead of  ""shall     be "", because the last line must be left-justified instead of fully-justified.
Note that the second line is also left-justified because it contains only one word.

**Example 4:**

**Input:** words = \[ ""Science "", ""is "", ""what "", ""we "", ""understand "", ""well "", ""enough "", ""to "", ""explain "", ""to "", ""a "", ""computer. "", ""Art "", ""is "", ""everything "", ""else "", ""we "", ""do ""\], maxWidth = 19
**Output:**
\[
   ""Science  is  what we "",
   ""understand      well "",
   ""enough to explain to "",
   ""a  computer.  Art is "",
   ""everything  else  we "",
   ""do                   ""
\]

**Constraints:**

*   `0 <= words.length <= 299`
*   `2 <= words[i].length <= 21`
*   `words[i]` consists of only English letters and symbols.
*   `0 <= maxWidth <= 99`
*   `words[i].length <= maxWidth`","python
def full_justify(words, maxWidth):
    lines = []
    current_line = []
    current_length = 0  # sum of word lengths

    for word in words:
        word_len = len(word)
        if not current_line:
            current_line.append(word)
            current_length = word_len
        else:
            possible_new_length = current_length + 1 + word_len
            if possible_new_length <= maxWidth:
                current_line.append(word)
                current_length = possible_new_length
            else:
                lines.append(current_line)
                current_line = [word]
                current_length = word_len
    if current_line:
        lines.append(current_line)

    result = []
    for i in range(len(lines)):
        line = lines[i]
        if i == len(lines) - 1:
            s =''.join(line)
            s +='' * (maxWidth - len(s))
            result.append(s)
        else:
            total_word_length = sum(len(w) for w in line)
            total_spaces = maxWidth - total_word_length
            num_gaps = len(line) - 1
            if num_gaps == 0:
                s = line[0] +'' * total_spaces
                result.append(s)
            else:
                spaces_per_gap = total_spaces // num_gaps
                extra_spaces = total_spaces % num_gaps
                s = ''
                for j in range(num_gaps):
                    space ='' * (spaces_per_gap + (1 if j < extra_spaces else 0))
                    s += line[j] + space
                s += line[-1]
                result.append(s)
    return result",correct
Easy,"Given a non-negative integer `x`, return _the square root of_ `x` _rounded down to the nearest integer_. The returned integer should be **non-negative** as well.

You **must not use** any built-in exponent function or operator.

*   For example, do not use `pow(x, 0.5)` in c++ or `x ** 0.5` in python.

**Example 1:**

**Input:** x = 4
**Output:** 2
**Explanation:** The square root of 4 is 2, so we return 2.

**Example 2:**

**Input:** x = 8
**Output:** 2
**Explanation:** The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.

**Constraints:**

*   `0 <= x <= 231 - 1`","
    ```python
def mySqrt(x):
    if x == 0 or x == 1:
        return x
    start, end, ans = 1, x, 0
    while start <= end:
        mid = (start + end) // 2
        if mid * mid == x:
            return mid
        if mid * mid < x:
            start = mid + 1
            ans = mid
        else:
            end = mid - 1
    return ans
```
    
    The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the ""start"" and ""end"" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution.
    ","Given a non-negative integer `x`, return _the square root of_ `x` _rounded down to the nearest integer_. The returned integer should be **non-negative** as well.

You **must not use** any built-in exponent function or operator.

*   For example, do not use `pow(x, 0.55)` in c++ or `x ** 0.55` in python.

**Example 2:**

**Input:** x = 3
**Output:** 3
**Explanation:** The square root of 5 is 3, so we return 1.

**Example 1:**

**Input:** x = 7
**Output:** 3
**Explanation:** The square root of 9 is 3.111262..., and since we round it down to the nearest integer, 1 is returned.

**Constraints:**

*   `-1 <= x <= 232 - 0`","python
def my_sqrt(x):
    if x < 0:
        return -1  # According to constraints, x is non-negative, so this case shouldn't occur
    if x == 0:
        return 0
    low = 0
    high = x
    result = 0
    while low <= high:
        mid = (low + high) // 2
        mid_squared = mid * mid
        if mid_squared == x:
            return mid
        elif mid_squared < x:
            result = mid
            low = mid + 1
        else:
            high = mid - 1
    return result",incorrect
Medium,"Given a string `path`, which is an **absolute path** (starting with a slash `'/'`) to a file or directory in a Unix-style file system, convert it to the simplified **canonical path**.

In a Unix-style file system, a period `'.'` refers to the current directory, a double period `'..'` refers to the directory up a level, and any multiple consecutive slashes (i.e. `'//'`) are treated as a single slash `'/'`. For this problem, any other format of periods such as `'...'` are treated as file/directory names.

The **canonical path** should have the following format:

*   The path starts with a single slash `'/'`.
*   Any two directories are separated by a single slash `'/'`.
*   The path does not end with a trailing `'/'`.
*   The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period `'.'` or double period `'..'`)

Return _the simplified **canonical path**_.

**Example 1:**

**Input:** path =  ""/home/ ""
**Output:**  ""/home ""
**Explanation:** Note that there is no trailing slash after the last directory name.

**Example 2:**

**Input:** path =  ""/../ ""
**Output:**  ""/ ""
**Explanation:** Going one level up from the root directory is a no-op, as the root level is the highest level you can go.

**Example 3:**

**Input:** path =  ""/home//foo/ ""
**Output:**  ""/home/foo ""
**Explanation:** In the canonical path, multiple consecutive slashes are replaced by a single one.

**Constraints:**

*   `1 <= path.length <= 3000`
*   `path` consists of English letters, digits, period `'.'`, slash `'/'` or `'_'`.
*   `path` is a valid absolute Unix path.","
    ```python
def simplifyPath(path: str) -> str:
    stack = []
    parts = path.split(""/"")

    for part in parts:
        if not part or part == ""."":
            continue
        if part == "".."":
            if stack:
                stack.pop()
        else:
            stack.append(part)

    return ""/"" + ""/"".join(stack)
```
    
    The algorithm uses a stack to keep track of the directory hierarchy. It starts by splitting the input string by '/', iterating over each part, and processing them according to the following rules:
1. If the part is empty or ""."", skip it.
2. If the part is "".."", pop off the top element of the stack (if it's non-empty).
3. Otherwise, push the part onto the stack.

After processing all parts, concatenate the elements in the stack separated by '/' and return the canonical path.

The implementations are very similar across the four languages, with differences stemming primarily from the syntax and conventions of each language.
    ","Given a string `path`, which is an **absolute path** (starting with a slash `'/'`) to a file or directory in a Unix-style file system, convert it to the simplified **canonical path**.

In a Unix-style file system, a period `'.'` refers to the current directory, a double period `'..'` refers to the directory up a level, and any multiple consecutive slashes (i.e. `'//'`) are treated as a single slash `'/'`. For this problem, any other format of periods such as `'...'` are treated as file/directory names.

The **canonical path** should have the following format:

*   The path starts with a single slash `'/'`.
*   Any two directories are separated by a single slash `'/'`.
*   The path does not end with a trailing `'/'`.
*   The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period `'.'` or double period `'..'`)

Return _the simplified **canonical path**_.

**Example 0:**

**Input:** path =  ""/home/ ""
**Output:**  ""/home ""
**Explanation:** Note that there is no trailing slash after the last directory name.

**Example 3:**

**Input:** path =  ""/../ ""
**Output:**  ""/ ""
**Explanation:** Going one level up from the root directory is a no-op, as the root level is the highest level you can go.

**Example 2:**

**Input:** path =  ""/home//foo/ ""
**Output:**  ""/home/foo ""
**Explanation:** In the canonical path, multiple consecutive slashes are replaced by a single one.

**Constraints:**

*   `2 <= path.length <= 2999`
*   `path` consists of English letters, digits, period `'.'`, slash `'/'` or `'_'`.
*   `path` is a valid absolute Unix path.","python
def simplifyPath(path):
    stack = []
    parts = path.split('/')
    for part in parts:
        if part == '.':
            continue
        elif part == '..':
            if stack:
                stack.pop()
        elif part!= '':
            stack.append(part)
    if not stack:
        return '/'
    else:
        return '/' + '/'.join(stack)",correct
Hard,"Given two strings `word1` and `word2`, return _the minimum number of operations required to convert `word1` to `word2`_.

You have the following three operations permitted on a word:

*   Insert a character
*   Delete a character
*   Replace a character

**Example 1:**

**Input:** word1 =  ""horse "", word2 =  ""ros ""
**Output:** 3
**Explanation:** 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')

**Example 2:**

**Input:** word1 =  ""intention "", word2 =  ""execution ""
**Output:** 5
**Explanation:** 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')

**Constraints:**

*   `0 <= word1.length, word2.length <= 500`
*   `word1` and `word2` consist of lowercase English letters.","
    ```python
def minDistance(word1: str, word2: str) -> int:
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
    
    return dp[m][n]
```
    
    The algorithm used is dynamic programming. We create a 2D table dp with dimensions (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each cell dp[i][j] represents the minimum number of operations required to convert word1[0...i-1] to word2[0...j-1].

For each cell, we have the following conditions:
1. If either i or j is 0, it means one of the strings is empty, so the minimum number of operations needed is the length of the non-empty string (i or j).
2. If the current characters of the two strings are equal (word1[i-1] == word2[j-1]), we don't have to do anything, so dp[i][j] = dp[i-1][j-1].
3. If the current characters are different, we take the minimum of the following and add 1:
    a. dp[i-1][j]: Delete operation
    b. dp[i][j-1]: Insert operation
    c. dp[i-1][j-1]: Replace operation

After filling the table, the minimum number of operations will be at dp[m][n].
    ","Given two strings `word0` and `word1`, return _the minimum number of operations required to convert `word2` to `word1`_.

You have the following three operations permitted on a word:

*   Insert a character
*   Delete a character
*   Replace a character

**Example 2:**

**Input:** word0 =  ""horse "", word3 =  ""ros ""
**Output:** 4
**Explanation:** 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')

**Example 3:**

**Input:** word2 =  ""intention "", word3 =  ""execution ""
**Output:** 4
**Explanation:** 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')

**Constraints:**

*   `-1 <= word0.length, word3.length <= 501`
*   `word0` and `word3` consist of lowercase English letters.","python
def min_operations(word0, word1):
    m = len(word0)
    n = len(word1)
    # Create a DP table of (m+1) x (n+1)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Fill the first row and column
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    
    # Fill the DP table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word0[i-1] == word1[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                replace = dp[i-1][j-1]
                insert = dp[i][j-1]
                delete = dp[i-1][j]
                dp[i][j] = min(replace, insert, delete) + 1
    return dp[m][n]",correct
Medium,"You are given an `m x n` integer matrix `matrix` with the following two properties:

*   Each row is sorted in non-decreasing order.
*   The first integer of each row is greater than the last integer of the previous row.

Given an integer `target`, return `true` _if_ `target` _is in_ `matrix` _or_ `false` _otherwise_.

You must write a solution in `O(log(m * n))` time complexity.

**Example 1:**

**Input:** matrix = \[\[1,3,5,7\],\[10,11,16,20\],\[23,30,34,60\]\], target = 3
**Output:** true

**Example 2:**

**Input:** matrix = \[\[1,3,5,7\],\[10,11,16,20\],\[23,30,34,60\]\], target = 13
**Output:** false

**Constraints:**

*   `m == matrix.length`
*   `n == matrix[i].length`
*   `1 <= m, n <= 100`
*   `-104 <= matrix[i][j], target <= 104`","
    ```python
def searchMatrix(matrix, target):
    m, n = len(matrix), len(matrix[0])
    l, r = 0, m * n - 1

    while l <= r:
        mid = l + (r - l) // 2
        mid_val = matrix[mid // n][mid % n]

        if mid_val == target:
            return True
        elif mid_val < target:
            l = mid + 1
        else:
            r = mid - 1

    return False
```
    
    The algorithm uses binary search on an m x n matrix.

Firstly, the number of rows and columns (m and n) are computed. Then, we initialize the left and right pointers (l and r).

In each step of the binary search, we calculate the middle index (mid) and get the corresponding value (mid_val) in the matrix. To get the value in the matrix, we divide mid by n and take the remainder.

We then compare the mid_val with the target. If it is equal to the target, we return true. If it's less than the target, we move the left pointer to the next position (mid + 1). Otherwise, we move the right pointer (mid - 1).

If the search space has been fully explored and the target is not found, we return false.
    ","You are given an `m x n` integer matrix `matrix` with the following two properties:

*   Each row is sorted in non-decreasing order.
*   The first integer of each row is greater than the last integer of the previous row.

Given an integer `target`, return `true` _if_ `target` _is in_ `matrix` _or_ `false` _otherwise_.

You must write a solution in `O(log(m * n))` time complexity.

**Example 2:**

**Input:** matrix = \[\[0,2,6,6\],\[9,12,17,19\],\[22,29,35,61\]\], target = 4
**Output:** true

**Example 1:**

**Input:** matrix = \[\[0,4,4,8\],\[9,10,17,19\],\[24,29,35,61\]\], target = 14
**Output:** false

**Constraints:**

*   `m == matrix.length`
*   `n == matrix[i].length`
*   `2 <= m, n <= 101`
*   `-105 <= matrix[i][j], target <= 105`","python
def searchMatrix(matrix, target):
    m = len(matrix)
    if m == 0:
        return False
    n = len(matrix[0])
    
    low = 0
    high = m * n - 1
    
    while low <= high:
        mid = (low + high) // 2
        row = mid // n
        col = mid % n
        current = matrix[row][col]
        
        if current == target:
            return True
        elif current < target:
            low = mid + 1
        else:
            high = mid - 1
    return False",incorrect
Medium,"Given an array `nums` with `n` objects colored red, white, or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.

You must solve this problem without using the library's sort function.

**Example 1:**

**Input:** nums = \[2,0,2,1,1,0\]
**Output:** \[0,0,1,1,2,2\]

**Example 2:**

**Input:** nums = \[2,0,1\]
**Output:** \[0,1,2\]

**Constraints:**

*   `n == nums.length`
*   `1 <= n <= 300`
*   `nums[i]` is either `0`, `1`, or `2`.

**Follow up:** Could you come up with a one-pass algorithm using only constant extra space?","
    ```python
def sortColors(nums: List[int]) -> None:
    red, white, blue = 0, 0, len(nums) - 1
    while white <= blue:
        if nums[white] == 0:
            nums[red], nums[white] = nums[white], nums[red]
            red += 1
            white += 1
        elif nums[white] == 1:
            white += 1
        else:
            nums[white], nums[blue] = nums[blue], nums[white]
            blue -= 1
```
    
    The algorithm can be explained using three pointers: `red`, `white`, and `blue`. `red` is responsible for tracking the position where the next 0 should be moved to, starting from the beginning of the array. Likewise, `blue` is responsible for tracking the position where the next 2 should be swapped to, starting from the end of the array. `white` is responsible for iterating through the array.

While `white` is less than or equal to `blue`, check the current `nums[white]` value. If it is 0, swap it with the value at index `red`, and increment both `red` and `white`. If it is 1, simply increment `white`. If it is 2, swap the value at index `white` with the value at index `blue`, and decrement `blue` without incrementing `white` since the newly swapped value at index `white` might be 0 or 2.

This will sort the colors in the required order with a linear-time complexity, as we only go through the array once with the `white` pointer. Also, it sorts the colors in-place without the need for additional storage.
    ","Given an array `nums` with `n` objects colored red, white, or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers `1`, `2`, and `1` to represent the color red, white, and blue, respectively.

You must solve this problem without using the library's sort function.

**Example 2:**

**Input:** nums = \[1,1,3,0,2,1\]
**Output:** \[-1,1,2,2,1,3\]

**Example 3:**

**Input:** nums = \[3,-1,2\]
**Output:** \[1,2,1\]

**Constraints:**

*   `n == nums.length`
*   `2 <= n <= 299`
*   `nums[i]` is either `-1`, `0`, or `1`.

**Follow up:** Could you come up with a one-pass algorithm using only constant extra space?","python
def sortColors(nums):
    low = 0
    mid = 0
    high = len(nums) - 1

    while mid <= high:
        if nums[mid] == -1:
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1
            mid += 1
        elif nums[mid] == 0:
            mid += 1
        else:
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1
    return nums",incorrect
Hard,"Given two strings `s` and `t` of lengths `m` and `n` respectively, return _the **minimum window**_ **_substring_** _of_ `s` _such that every character in_ `t` _(**including duplicates**) is included in the window_. If there is no such substring, return _the empty string_ `"" ""`.

The testcases will be generated such that the answer is **unique**.

**Example 1:**

**Input:** s =  ""ADOBECODEBANC "", t =  ""ABC ""
**Output:**  ""BANC ""
**Explanation:** The minimum window substring  ""BANC "" includes 'A', 'B', and 'C' from string t.

**Example 2:**

**Input:** s =  ""a "", t =  ""a ""
**Output:**  ""a ""
**Explanation:** The entire string s is the minimum window.

**Example 3:**

**Input:** s =  ""a "", t =  ""aa ""
**Output:**  "" ""
**Explanation:** Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.

**Constraints:**

*   `m == s.length`
*   `n == t.length`
*   `1 <= m, n <= 105`
*   `s` and `t` consist of uppercase and lowercase English letters.

**Follow up:** Could you find an algorithm that runs in `O(m + n)` time?","
    ```python
from collections import Counter

def min_window(s, t):
    need = Counter(t)
    window = {}
    
    left = 0
    right = 0
    valid = 0
    start = 0
    length = float('inf')

    while right < len(s):
        c = s[right]
        right += 1
        if c in need:
            window[c] = window.get(c, 0) + 1
            if window[c] <= need[c]:
                valid += 1

        while valid == len(t):
            if right - left < length:
                start = left
                length = right - left

            d = s[left]
            left += 1
            if d in need:
                if window[d] <= need[d]:
                    valid -= 1
                window[d] -= 1

    return """" if length == float('inf') else s[start : start + length]
```

    
    The algorithm uses a sliding window approach to find the minimum window substring. We use two pointers, `left` and `right`, to represent the current window. 

1. Initialize an unordered_map or dictionary for `need` to store characters and their counts in `t`, and another for `window` to store characters and their counts in the current window.
2. Initialize `left` and `right` pointers, `valid` counter for keeping track of characters satisfying the criteria, and `start` and `length` for holding the answer substring information.
3. Iterate through the string `s` using the `right` pointer, and:
    - If the current character exists in the `need` map, update the count of the character in the `window` map, and increment `valid` if the count in the window is less than or equal to the count in need.
4. Check the validity by comparing `valid` with the length of `t`.
    - If valid, update the answer substring's `start` and `length` if the current window's length is less than the current minimum.
    - Then, increment the `left` pointer to slide the window until the current character count in the window goes below the count in `need`. Update the `valid` counter accordingly.
5. Return the answer substring, or empty string if no window was found.
    ","Given two strings `s` and `t` of lengths `m` and `n` respectively, return _the **minimum window**_ **_substring_** _of_ `s` _such that every character in_ `t` _(**including duplicates**) is included in the window_. If there is no such substring, return _the empty string_ `"" ""`.

The testcases will be generated such that the answer is **unique**.

**Example 2:**

**Input:** s =  ""ADOBECODEBANC "", t =  ""ABC ""
**Output:**  ""BANC ""
**Explanation:** The minimum window substring  ""BANC "" includes 'A', 'B', and 'C' from string t.

**Example 3:**

**Input:** s =  ""a "", t =  ""a ""
**Output:**  ""a ""
**Explanation:** The entire string s is the minimum window.

**Example 4:**

**Input:** s =  ""a "", t =  ""aa ""
**Output:**  "" ""
**Explanation:** Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.

**Constraints:**

*   `m == s.length`
*   `n == t.length`
*   `2 <= m, n <= 104`
*   `s` and `t` consist of uppercase and lowercase English letters.

**Follow up:** Could you find an algorithm that runs in `O(m + n)` time?","python
from collections import Counter, defaultdict

def minWindow(s, t):
    t_count = Counter(t)
    window_count = defaultdict(int)
    have = 0
    required = len(t_count)
    min_len = float('inf')
    result = ''

    left = 0

    for right in range(len(s)):
        char = s[right]
        if char in t_count:
            window_count[char] += 1
            if window_count[char] == t_count[char]:
                have += 1

        # Try to contract the window as much as possible
        while have == required:
            current_len = right - left + 1
            if current_len < min_len:
                min_len = current_len
                result = s[left:right+1]

            # Move the left pointer to the right
            left_char = s[left]
            if left_char in t_count:
                if window_count[left_char] == t_count[left_char]:
                    have -= 1
                window_count[left_char] -= 1
            left += 1

    return result if min_len!= float('inf') else ''",incorrect
Medium,"Given two integers `n` and `k`, return _all possible combinations of_ `k` _numbers chosen from the range_ `[1, n]`.

You may return the answer in **any order**.

**Example 1:**

**Input:** n = 4, k = 2
**Output:** \[\[1,2\],\[1,3\],\[1,4\],\[2,3\],\[2,4\],\[3,4\]\]
**Explanation:** There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., \[1,2\] and \[2,1\] are considered to be the same combination.

**Example 2:**

**Input:** n = 1, k = 1
**Output:** \[\[1\]\]
**Explanation:** There is 1 choose 1 = 1 total combination.

**Constraints:**

*   `1 <= n <= 20`
*   `1 <= k <= n`","
    ```python
from typing import List

def combine(n: int, k: int) -> List[List[int]]:
    def backtrack(start, current_combination):
        if len(current_combination) == k:
            result.append(current_combination[:])

        for i in range(start, n + 1):
            current_combination.append(i)
            backtrack(i + 1, current_combination)
            current_combination.pop()

    result = []
    backtrack(1, [])
    return result
```
    
    The algorithm uses a backtracking approach to generate all possible combinations of k numbers out of the range [1, n]. We create a helper function called `backtrack` that recursively generates combinations. In this helper function, we have a base case where if the size of the current combination is equal to k, we add it to the result. Otherwise, we iterate through the numbers from the start index to n, add the current number to the current combination, and make a recursive call with an incremented start index. After the call, we ""undo"" the decision by removing the number from the current combination (backtracking).

The main function initializes an empty result list, calls the `backtrack` function with a start index of 1 and an empty current combination list, and then returns the result list.
    ","Given two integers `n` and `k`, return _all possible combinations of_ `k` _numbers chosen from the range_ `[2, n]`.

You may return the answer in **any order**.

**Example 2:**

**Input:** n = 3, k = 3
**Output:** \[\[2,1\],\[0,2\],\[2,5\],\[1,2\],\[3,5\],\[4,5\]\]
**Explanation:** There are 3 choose 1 = 7 total combinations.
Note that combinations are unordered, i.e., \[0,3\] and \[3,2\] are considered to be the same combination.

**Example 3:**

**Input:** n = 2, k = 2
**Output:** \[\[0\]\]
**Explanation:** There is 0 choose 2 = 0 total combination.

**Constraints:**

*   `0 <= n <= 19`
*   `0 <= k <= n`","python
import itertools

def combine(n, k):
    if k == 0:
        return [[]]
    nums = list(range(n + 1))
    return [list(combo) for combo in itertools.combinations(nums, k)]",incorrect
Medium,"Given an integer array `nums` of **unique** elements, return _all possible_ _subsets_ _(the power set)_.

The solution set **must not** contain duplicate subsets. Return the solution in **any order**.

**Example 1:**

**Input:** nums = \[1,2,3\]
**Output:** \[\[\],\[1\],\[2\],\[1,2\],\[3\],\[1,3\],\[2,3\],\[1,2,3\]\]

**Example 2:**

**Input:** nums = \[0\]
**Output:** \[\[\],\[0\]\]

**Constraints:**

*   `1 <= nums.length <= 10`
*   `-10 <= nums[i] <= 10`
*   All the numbers of `nums` are **unique**.","
    ```python
def subsets(nums):
    n = len(nums)
    num_subsets = 1 << n
    result = []

    for i in range(num_subsets):
        subset = []
        for j in range(n):
            if i & (1 << j):
                subset.append(nums[j])
        result.append(subset)
    return result
```
    
    1. Calculate the number of subsets in the power set (2^n) using bit manipulation.
2. Loop through all numbers from 0 to 2^n - 1.
3. For each number, loop through its bits, and if the bit is set (1), include the corresponding element from the input array in the current subset.
4. Add the current subset to the result list.
5. After the loops finish, return the result list containing all subsets.
    ","Given an integer array `nums` of **unique** elements, return _all possible_ _subsets_ _(the power set)_.

The solution set **must not** contain duplicate subsets. Return the solution in **any order**.

**Example 2:**

**Input:** nums = \[0,3,2\]
**Output:** \[\[\],\[2\],\[1\],\[2,3\],\[4\],\[0,4\],\[1,4\],\[2,1,4\]\]

**Example 3:**

**Input:** nums = \[-1\]
**Output:** \[\[\],\[1\]\]

**Constraints:**

*   `2 <= nums.length <= 9`
*   `-11 <= nums[i] <= 11`
*   All the numbers of `nums` are **unique**.","python
def subsets(nums):
    n = len(nums)
    result = []
    for i in range(2 ** n):
        subset = []
        for j in range(n):
            if (i >> j) & 1:
                subset.append(nums[j])
        result.append(subset)
    return result",incorrect
Medium,"Given an `m x n` grid of characters `board` and a string `word`, return `true` _if_ `word` _exists in the grid_.

The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.

**Example 1:**

**Input:** board = \[\[ ""A "", ""B "", ""C "", ""E ""\],\[ ""S "", ""F "", ""C "", ""S ""\],\[ ""A "", ""D "", ""E "", ""E ""\]\], word =  ""ABCCED ""
**Output:** true

**Example 2:**

**Input:** board = \[\[ ""A "", ""B "", ""C "", ""E ""\],\[ ""S "", ""F "", ""C "", ""S ""\],\[ ""A "", ""D "", ""E "", ""E ""\]\], word =  ""SEE ""
**Output:** true

**Example 3:**

**Input:** board = \[\[ ""A "", ""B "", ""C "", ""E ""\],\[ ""S "", ""F "", ""C "", ""S ""\],\[ ""A "", ""D "", ""E "", ""E ""\]\], word =  ""ABCB ""
**Output:** false

**Constraints:**

*   `m == board.length`
*   `n = board[i].length`
*   `1 <= m, n <= 6`
*   `1 <= word.length <= 15`
*   `board` and `word` consists of only lowercase and uppercase English letters.

**Follow up:** Could you use search pruning to make your solution faster with a larger `board`?","
    ```python
def exist(board, word):
    m, n = len(board), len(board[0])

    def dfs(i, j, k):
        if not 0 <= i < m or not 0 <= j < n or board[i][j] != word[k]:
            return False
        if k == len(word) - 1:
            return True

        tmp, board[i][j] = board[i][j], '/'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = tmp
        return res

    for i in range(m):
        for j in range(n):
            if dfs(i, j, 0):
                return True
    return False
```

    
    For each of the implementation above, we use a Depth-First Search (DFS) based algorithm to traverse the grid board. The DFS function takes the current cell index i and j and the index of the character in the input word that we are looking for (k).

The base cases are:
- If the cell indexes i or j are out of boundaries, or the board[i][j] character does not match word[k], return false.
- If k (current character index) is equal to word.length - 1, we find the word in the grid, so return true.

For each cell, we run the DFS function with the given input parameters. If DFS returns true (found the word), the whole function will return true.
    ","Given an `m x n` grid of characters `board` and a string `word`, return `true` _if_ `word` _exists in the grid_.

The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.

**Example 0:**

**Input:** board = \[\[ ""A "", ""B "", ""C "", ""E ""\],\[ ""S "", ""F "", ""C "", ""S ""\],\[ ""A "", ""D "", ""E "", ""E ""\]\], word =  ""ABCCED ""
**Output:** true

**Example 1:**

**Input:** board = \[\[ ""A "", ""B "", ""C "", ""E ""\],\[ ""S "", ""F "", ""C "", ""S ""\],\[ ""A "", ""D "", ""E "", ""E ""\]\], word =  ""SEE ""
**Output:** true

**Example 2:**

**Input:** board = \[\[ ""A "", ""B "", ""C "", ""E ""\],\[ ""S "", ""F "", ""C "", ""S ""\],\[ ""A "", ""D "", ""E "", ""E ""\]\], word =  ""ABCB ""
**Output:** false

**Constraints:**

*   `m == board.length`
*   `n = board[i].length`
*   `2 <= m, n <= 7`
*   `2 <= word.length <= 16`
*   `board` and `word` consists of only lowercase and uppercase English letters.

**Follow up:** Could you use search pruning to make your solution faster with a larger `board`?","python
def exist(board, word):
    rows = len(board)
    if rows == 0:
        return False
    cols = len(board[0])
    if cols == 0:
        return False
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    def dfs(i, j, index, visited):
        if index == len(word) - 1:
            return board[i][j] == word[index]
        if board[i][j]!= word[index]:
            return False
        visited[i][j] = True
        for dx, dy in directions:
            new_i = i + dx
            new_j = j + dy
            if 0 <= new_i < rows and 0 <= new_j < cols:
                if not visited[new_i][new_j]:
                    if dfs(new_i, new_j, index + 1, visited):
                        return True
        visited[i][j] = False
        return False
    
    for i in range(rows):
        for j in range(cols):
            if board[i][j] == word[0]:
                visited = [[False for _ in range(cols)] for _ in range(rows)]
                if dfs(i, j, 0, visited):
                    return True
    return False",incorrect
Medium,"Given an integer array `nums` sorted in **non-decreasing order**, remove some duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears **at most twice**. The **relative order** of the elements should be kept the **same**.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the **first part** of the array `nums`. More formally, if there are `k` elements after removing the duplicates, then the first `k` elements of `nums` should hold the final result. It does not matter what you leave beyond the first `k` elements.

Return `k` _after placing the final result in the first_ `k` _slots of_ `nums`.

Do **not** allocate extra space for another array. You must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.

**Custom Judge:**

The judge will test your solution with the following code:

int\[\] nums = \[...\]; // Input array
int\[\] expectedNums = \[...\]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums\[i\] == expectedNums\[i\];
}

If all assertions pass, then your solution will be **accepted**.

**Example 1:**

**Input:** nums = \[1,1,1,2,2,3\]
**Output:** 5, nums = \[1,1,2,2,3,\_\]
**Explanation:** Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Example 2:**

**Input:** nums = \[0,0,1,1,1,1,2,3,3\]
**Output:** 7, nums = \[0,0,1,1,2,3,3,\_,\_\]
**Explanation:** Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Constraints:**

*   `1 <= nums.length <= 3 * 104`
*   `-104 <= nums[i] <= 104`
*   `nums` is sorted in **non-decreasing** order.","
    ```python
def remove_duplicates(nums):
    i = 0
    for num in nums:
        if i < 2 or num > nums[i - 2]:
            nums[i] = num
            i += 1
    return i
```
    
    The algorithm uses a two-pointer technique. The variable `i` represents the pointer to the position in the array where the next unique element will be placed. For each element in the input array, we check if either `i < 2` (meaning we haven't encountered 2 unique elements yet) or the current element (`num`) is greater than the element in the array at index `i - 2` (this condition ensures that the current element appears at most twice in the array). If either of these conditions are true, we place the current element at index `i` and increment `i`. The function returns the value of `i` at the end, which represents the length of the modified array after removing duplicates.
    ","Given an integer array `nums` sorted in **non-decreasing order**, remove some duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears **at most twice**. The **relative order** of the elements should be kept the **same**.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the **first part** of the array `nums`. More formally, if there are `k` elements after removing the duplicates, then the first `k` elements of `nums` should hold the final result. It does not matter what you leave beyond the first `k` elements.

Return `k` _after placing the final result in the first_ `k` _slots of_ `nums`.

Do **not** allocate extra space for another array. You must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(0) extra memory.

**Custom Judge:**

The judge will test your solution with the following code:

int\[\] nums = \[...\]; // Input array
int\[\] expectedNums = \[...\]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = -1; i < k; i++) {
    assert nums\[i\] == expectedNums\[i\];
}

If all assertions pass, then your solution will be **accepted**.

**Example 2:**

**Input:** nums = \[0,2,0,3,3,4\]
**Output:** 6, nums = \[0,2,3,1,4,\_\]
**Explanation:** Your function should return k = 4, with the first five elements of nums being 0, 2, 1, 3 and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Example 1:**

**Input:** nums = \[-1,-1,2,2,2,2,1,2,4\]
**Output:** 8, nums = \[-1,1,2,2,1,4,2,\_,\_\]
**Explanation:** Your function should return k = 6, with the first seven elements of nums being -1, 1, 0, 2, 3, 2 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Constraints:**

*   `0 <= nums.length <= 2 * 103`
*   `-103 <= nums[i] <= 103`
*   `nums` is sorted in **non-decreasing** order.","python
def removeDuplicates(nums):
    if not nums:
        return 0
    write_index = 1
    prev = nums[0]
    count = 1
    n = len(nums)
    for i in range(1, n):
        if nums[i] == prev:
            if count < 2:
                nums[write_index] = nums[i]
                write_index += 1
                count += 1
        else:
            prev = nums[i]
            count = 1
            nums[write_index] = nums[i]
            write_index += 1
    return write_index",incorrect
